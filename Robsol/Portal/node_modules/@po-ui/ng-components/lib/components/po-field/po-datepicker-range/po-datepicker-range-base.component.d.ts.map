{"version":3,"file":"po-datepicker-range-base.component.d.ts","sources":["po-datepicker-range-base.component.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { EventEmitter } from '@angular/core';\r\nimport { AbstractControl, ControlValueAccessor, ValidationErrors, Validator } from '@angular/forms';\r\nimport { PoLanguageService } from '../../../services/po-language/po-language.service';\r\nimport { PoDateService } from './../../../services/po-date/po-date.service';\r\nimport { PoDatepickerRangeLiterals } from './interfaces/po-datepicker-range-literals.interface';\r\nimport { PoDatepickerRange } from './interfaces/po-datepicker-range.interface';\r\n/**\r\n * @description\r\n *\r\n * O `po-datepicker-range` é um componente para seleção de um período entre duas datas, onde é possível informar apenas\r\n * a data inicial ou a data final.\r\n *\r\n * O componente `[(ngModel)]` do `po-datepicker-range` trabalha com um objeto que implementa a interface\r\n * `PoDatepickerRange`, contendo as seguintes propriedades:\r\n * ```\r\n * { \"start\": '2017-11-28', \"end\": '2017-11-30' }\r\n * ```\r\n *\r\n * <a id=\"accepted-formats\"></a>\r\n * Este componente pode receber os seguintes formatos de data:\r\n *\r\n * - **Data e hora combinados (E8601DZw): yyyy-mm-ddThh:mm:ss+|-hh:mm**\r\n * ```\r\n * '2017-11-28T00:00:00-02:00';\r\n * ```\r\n *\r\n * - **Data (E8601DAw.): yyyy-mm-dd**\r\n * ```\r\n * '2017-11-28';\r\n * ```\r\n *\r\n * - **JavaScript Date Object:**\r\n * ```\r\n * new Date(2017, 10, 28);\r\n * ```\r\n *\r\n * > O componente respeitará o formato passado para o *model* via codificação. Porém, caso seja feita alteração em algum\r\n * dos valores de data em tela, o componente atribuirá o formato **Data (E8601DAw.): yyyy-mm-dd** ao model.\r\n *\r\n * Importante:\r\n *\r\n * - Quando preenchidas a data inicial e final, a data inicial deve ser sempre menor ou igual a data final;\r\n * - Ao passar uma data inválida via codificação, o valor será mantido no *model* e o `input` da tela aparecerá vazio;\r\n * - Permite trabalhar com as duas datas separadamente através das propriedades `p-start-date` e `p-end-date` no lugar do\r\n * `[(ngModel)]`, no entanto sem a validação do formulário;\r\n * - Para a validação do formulário, utilize o `[(ngModel)]`.\r\n */\r\nexport declare abstract class PoDatepickerRangeBaseComponent implements ControlValueAccessor, Validator {\r\n    protected poDateService: PoDateService;\r\n    /**\r\n     * @optional\r\n     *\r\n     * @description\r\n     *\r\n     * Aplica foco no elemento ao ser iniciado.\r\n     *\r\n     * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.\r\n     *\r\n     * @default `false`\r\n     */\r\n    autoFocus: boolean;\r\n    /**\r\n     * @optional\r\n     *\r\n     * @description\r\n     *\r\n     * Texto de apoio do campo.\r\n     */\r\n    help?: string;\r\n    /**\r\n     * @optional\r\n     *\r\n     * @description\r\n     *\r\n     * Rótulo do campo.\r\n     */\r\n    label?: string;\r\n    /**\r\n     * @optional\r\n     *\r\n     * @description\r\n     *\r\n     * Define se a indicação de campo opcional será exibida.\r\n     *\r\n     * > Não será exibida a indicação se:\r\n     * - O campo conter `p-required`;\r\n     * - Não possuir `p-help` e/ou `p-label`.\r\n     *\r\n     * @default `false`\r\n     */\r\n    optional: boolean;\r\n    /**\r\n     * @optional\r\n     *\r\n     * @description\r\n     *\r\n     * Evento disparado ao alterar valor do campo.\r\n     */\r\n    onChange: EventEmitter<any>;\r\n    errorMessage: string;\r\n    dateRange: PoDatepickerRange;\r\n    protected format: any;\r\n    protected isDateRangeInputFormatValid: boolean;\r\n    protected isStartDateRangeInputValid: boolean;\r\n    protected onTouchedModel: any;\r\n    private _clean?;\r\n    private _disabled?;\r\n    private _endDate?;\r\n    private _literals?;\r\n    private _maxDate;\r\n    private _minDate;\r\n    private _noAutocomplete?;\r\n    private _readonly;\r\n    private _required?;\r\n    private _startDate?;\r\n    private language;\r\n    private onChangeModel;\r\n    private validatorChange;\r\n    get isDateRangeInputValid(): boolean;\r\n    /**\r\n     * @optional\r\n     *\r\n     * @description\r\n     *\r\n     * Habilita ação para limpar o campo.\r\n     *\r\n     * @default `false`\r\n     */\r\n    set clean(clean: boolean);\r\n    get clean(): boolean;\r\n    /**\r\n     * @optional\r\n     *\r\n     * @description\r\n     *\r\n     * Desabilita o campo.\r\n     *\r\n     * @default `false`\r\n     */\r\n    set disabled(value: boolean);\r\n    get disabled(): boolean;\r\n    /**\r\n     * @optional\r\n     *\r\n     * @description\r\n     *\r\n     * Data final.\r\n     */\r\n    set endDate(date: string | Date);\r\n    get endDate(): string | Date;\r\n    /**\r\n     * @optional\r\n     *\r\n     * @description\r\n     *\r\n     * Objeto com as literais usadas no `po-datepicker-range`.\r\n     *\r\n     * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:\r\n     *\r\n     * ```\r\n     *  const customLiterals: PoDatepickerRangeLiterals = {\r\n     *    invalidFormat: 'Date in inconsistent format',\r\n     *    startDateGreaterThanEndDate: 'End date less than start date'\r\n     *  };\r\n     * ```\r\n     *\r\n     * Ou passando apenas as literais que deseja customizar:\r\n     *\r\n     * ```\r\n     *  const customLiterals: PoDatepickerRangeLiterals = {\r\n     *    invalidFormat: 'Date in inconsistent format'\r\n     *  };\r\n     * ```\r\n     *\r\n     * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.\r\n     *\r\n     * ```\r\n     * <po-datepicker-range\r\n     *   [p-literals]=\"customLiterals\">\r\n     * </po-datepicker-range>\r\n     * ```\r\n     *\r\n     * > O objeto padrão de literais será traduzido de acordo com o idioma do\r\n     * [`PoI18nService`](/documentation/po-i18n) ou do browser.\r\n     */\r\n    set literals(value: PoDatepickerRangeLiterals);\r\n    get literals(): PoDatepickerRangeLiterals;\r\n    /**\r\n     * @optional\r\n     *\r\n     * @description\r\n     *\r\n     * Define uma data mínima para o `po-datepicker-range`.\r\n     */\r\n    set minDate(value: string | Date);\r\n    get minDate(): string | Date;\r\n    /**\r\n     * @optional\r\n     *\r\n     * @description\r\n     *\r\n     * Define uma data máxima para o `po-datepicker-range`.\r\n     */\r\n    set maxDate(value: string | Date);\r\n    get maxDate(): string | Date;\r\n    /**\r\n     * @optional\r\n     *\r\n     * @description\r\n     *\r\n     * Define a propriedade nativa `autocomplete` do campo como `off`.\r\n     *\r\n     * @default `false`\r\n     */\r\n    set noAutocomplete(value: boolean);\r\n    get noAutocomplete(): boolean;\r\n    /**\r\n     * @optional\r\n     *\r\n     * @description\r\n     *\r\n     * Indica que o campo será somente leitura.\r\n     *\r\n     * @default `false`\r\n     */\r\n    set readonly(value: boolean);\r\n    get readonly(): boolean;\r\n    /**\r\n     * @optional\r\n     *\r\n     * @description\r\n     *\r\n     * Indica que o campo será obrigatório.\r\n     *\r\n     * @default `false`\r\n     */\r\n    set required(required: boolean);\r\n    get required(): boolean;\r\n    /**\r\n     * @optional\r\n     *\r\n     * @description\r\n     *\r\n     * Data inicial.\r\n     */\r\n    set startDate(date: string | Date);\r\n    get startDate(): string | Date;\r\n    constructor(poDateService: PoDateService, languageService: PoLanguageService);\r\n    setDisabledState(isDisabled: boolean): void;\r\n    registerOnChange(func: any): void;\r\n    registerOnTouched(func: any): void;\r\n    registerOnValidatorChange?(fn: () => void): void;\r\n    validate(control: AbstractControl): ValidationErrors;\r\n    validateDateInRange(startDate: any): boolean;\r\n    writeValue(dateRange: PoDatepickerRange): void;\r\n    protected dateFormatFailed(value: string): boolean;\r\n    protected updateModel(value: any): void;\r\n    protected validateModel(value: any): void;\r\n    protected verifyValidDate(startDate: string, endDate: string): boolean;\r\n    private convertPatternDateFormat;\r\n    private dateRangeFailed;\r\n    private dateRangeFormatFailed;\r\n    private dateRangeObjectFailed;\r\n    private isDateRangeObject;\r\n    private requiredDateRangeFailed;\r\n    private dateIsValid;\r\n    protected abstract resetDateRangeInputValidation(): void;\r\n    protected abstract updateScreenByModel(dateRange: PoDatepickerRange): any;\r\n}\r\n"]}