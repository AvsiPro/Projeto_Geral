{"version":3,"file":"po-dynamic-form-base.component.d.ts","sources":["po-dynamic-form-base.component.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { EventEmitter } from '@angular/core';\r\nimport { NgForm } from '@angular/forms';\r\nimport { PoDynamicFormField } from './po-dynamic-form-field.interface';\r\n/**\r\n *\r\n * @description\r\n *\r\n * Componente para criação de formulários dinâmicos a partir de uma lista de objetos.\r\n *\r\n * Também é possível verificar se o formulário está válido e informar valores para a exibição de informações.\r\n */\r\nexport declare class PoDynamicFormBaseComponent {\r\n    /**\r\n     * @optional\r\n     *\r\n     * @description\r\n     *\r\n     * Nome da propriedade, atribuída ao `PoDynamicFormField.property`, que iniciará o campo com foco.\r\n     */\r\n    autoFocus?: string;\r\n    /**\r\n     * @description\r\n     *\r\n     * Coleção de objetos que implementam a interface `PoDynamicFormField`, para definição dos campos que serão criados\r\n     * dinamicamente.\r\n     *\r\n     * > Ex: `[ { property: 'name' } ]`\r\n     *\r\n     * Regras de tipagem e criação dos componentes:\r\n     *\r\n     * - Caso o *type* informado seja *boolean* o componente criado será o `po-switch`.\r\n     * - Caso o *type* informado seja *currency* e não seja informado um *mask* ou *pattern* o componente criado será o `po-decimal`,\r\n     * caso seja informado um *mask* ou *pattern* o componente criado será o `po-input`.\r\n     * - Caso o *type* informado seja *number* e não seja informado um *mask* ou *pattern* o componente criado será o `po-number`, caso seja\r\n     * informado um *mask* ou *pattern* o componente criado será o `po-input`.\r\n     * - Caso a lista possua a propriedade `options` e a mesma possua até 3 itens o componente criado será o `po-radio-group`\r\n     * ou `po-checkbox-group` se informar a propriedade `optionsMulti`.\r\n     * - Caso a mesma possua 3 ou mais itens, será criado o componente `po-select` ou, `po-multiselect` se a propriedade `optionsMulti`\r\n     * for verdadeira.\r\n     * - Caso o *type* informado seja *date* ou *datetime* o componente criado será o `po-datepicker`.\r\n     * - Caso seja informado a propriedade `optionsService` o componente criado será o `po-combo`.\r\n     * - Caso o *type* informado seja *time* o componente criado será um `po-input` podendo receber um *mask* para formatar\r\n     * o valor exibido, caso não seja informado um *mask* o componente será criado com a máscara '99:99' por padrão.\r\n     * - Caso a lista possua a propriedade `rows` e esta seja definida com valor maior ou igual a 3 o componente criado será\r\n     * o `po-textarea`, caso o valor da propriedade `rows` seja menor que 3 o componente criado será o `po-input`.\r\n     * - Caso seja informada a propriedade `secret` o componente criado será o `po-password`.\r\n     * - Caso o *type* informado seja *string* o componente criado será o `po-input`.\r\n     *\r\n     * @default `[]`\r\n     */\r\n    fields: Array<PoDynamicFormField>;\r\n    /**\r\n     * Objeto que será utilizado como valor para exibir as informações, será recuperado e preenchido através do atributo *property*\r\n     * dos objetos contidos na propridade `p-fields`.\r\n     *\r\n     * Pode iniciar com valor ou apenas com um objeto vazio que será preenchido conforme descrito acima.\r\n     *\r\n     * > Ex: `{ name: 'po' }`\r\n     */\r\n    value: any;\r\n    /**\r\n     * @optional\r\n     *\r\n     * @description\r\n     *\r\n     * Na inicialização do componente será repassado o objeto de formulário utilizado no componente,\r\n     * podendo ser utilizado para validações e/ou detecção de mudança dos valores.\r\n     *\r\n     * Portanto existem duas maneiras de recuperar o formulário,\r\n     * através de *template reference* e através do *output*, veja os exemplos abaixo:\r\n     *\r\n     * > *template reference*\r\n     *\r\n     * ```html\r\n     *  <po-dynamic-form #dynamicForm>\r\n     *  </po-dynamic-form>\r\n     *\r\n     *  <po-button p-label=\"Adicionar\" [p-disabled]=\"dynamicForm?.form.invalid\">\r\n     *  </po-button>\r\n     *\r\n     * ```\r\n     *\r\n     * > *Output*\r\n     *\r\n     * ```html\r\n     *  ...\r\n     *  <po-dynamic-form (p-form)=\"getForm($event)\">\r\n     *  </po-dynamic-form>\r\n     *\r\n     *  <po-button p-label=\"Adicionar\" [p-disabled]=\"dynamicForm?.invalid\">\r\n     *  </po-button>\r\n     *  ...\r\n     *\r\n     * ```\r\n     *\r\n     * ```ts\r\n     *  ...\r\n     *\r\n     *  export class AppComponent {\r\n     *\r\n     *    dynamicForm: NgForm;\r\n     *\r\n     *    getForm(form: NgForm) {\r\n     *      this.dynamicForm = form;\r\n     *    }\r\n     *\r\n     *  }\r\n     * ```\r\n     *\r\n     * > Caso a propriedade `p-group-form` for verdadeira não será repassado o formulário, pois o mesmo utilizará\r\n     * o formulário pai.\r\n     */\r\n    formOutput: EventEmitter<NgForm>;\r\n    /**\r\n     * Função ou serviço que será executado na inicialização do componente.\r\n     *\r\n     * A propriedade aceita os seguintes tipos:\r\n     * - `string`: *Endpoint* usado pelo componente para requisição via `POST`.\r\n     * - `function`: Método que será executado.\r\n     *\r\n     * Ao ser executado, irá receber como parâmetro o objeto informado no `p-value`.\r\n     *\r\n     * O retorno desta função deve ser do tipo [PoDynamicFormLoad](documentation/po-dynamic-form#po-dynamic-form-load),\r\n     * onde o usuário poderá determinar as novas atualizações dos campos, valores e determinar o campo a ser focado.\r\n     *\r\n     * Por exemplo:\r\n     *\r\n     * ```\r\n     * onLoadFields(): PoDynamicFormLoad {\r\n     *\r\n     *   return {\r\n     *     value: { cpf: undefined },\r\n     *     fields: [\r\n     *       { property: 'cpf' }\r\n     *     ],\r\n     *     focus: 'cpf'\r\n     *   };\r\n     * }\r\n     *\r\n     * ```\r\n     * Para referenciar a sua função utilize a propriedade `bind`, por exemplo:\r\n     * ```\r\n     *  [p-load]=\"onLoadFields.bind(this)\"\r\n     * ```\r\n     */\r\n    load?: string | Function;\r\n    /**\r\n     * Função ou serviço para validar as **mudanças do formulário**.\r\n     *\r\n     * A propriedade aceita os seguintes tipos:\r\n     * - `string`: *Endpoint* usado pelo componente para requisição via `POST`.\r\n     * - `function`: Método que será executado.\r\n     *\r\n     * Ao ser executado, irá receber como parâmetro um objeto com o nome da propriedade\r\n     * alterada e o novo valor, conforme a interface `PoDynamicFormFieldChanged`:\r\n     *\r\n     * ```\r\n     * { property: 'property name', value: 'new value' }\r\n     * ```\r\n     *\r\n     * O retorno desta função deve ser do tipo [PoDynamicFormValidation](documentation/po-dynamic-form#po-dynamic-form-validation),\r\n     * onde o usuário poderá determinar as novas atualizações dos campos.\r\n     * Por exemplo:\r\n     *\r\n     * ```\r\n     * onChangeFields(changeValue): PoDynamicFormValidation {\r\n     *\r\n     * if (changeValue.property === 'state') {\r\n     *\r\n     *   return {\r\n     *     value: { city: undefined },\r\n     *     fields: [\r\n     *       { property: 'city', options: this.getCity(changeValue.value.state) }\r\n     *     ],\r\n     *     focus: 'city'\r\n     *   };\r\n     * }\r\n     *\r\n     * ```\r\n     * Para referenciar a sua função utilize a propriedade `bind`, por exemplo:\r\n     * ```\r\n     *  [p-validate]=\"this.myFunction.bind(this)\"\r\n     * ```\r\n     *\r\n     * > Se houver uma lista de campos para validação definida em `p-validate-fields`, a propriedade `validate` só receberá o disparo para os campos equivalentes.\r\n     */\r\n    validate?: string | Function;\r\n    /**\r\n     * @optional\r\n     *\r\n     * @description\r\n     *\r\n     * Lista que define os campos que irão disparar o validate do form.\r\n     */\r\n    validateFields?: Array<string>;\r\n    private _groupForm?;\r\n    /**\r\n     * @optional\r\n     *\r\n     * @description\r\n     * Ao informar esta propriedade, o componente passará a utilizar o formulário pai para criar os `FormControl`\r\n     * e com isso é possível recuperar o valor do formulário e suas validações a partir do formulário pai.\r\n     *\r\n     * ```html\r\n     * <form #parentForm=\"ngForm\">\r\n     *\r\n     *   <po-dynamic-form p-group-form [p-fields]=\"fields\"></po-dynamic-form>\r\n     *\r\n     *  <po-button p-label=\"Adicionar\" [p-disabled]=\"parentForm.invalid\"></po-button>\r\n     * </form>\r\n     * ```\r\n     */\r\n    set groupForm(value: boolean);\r\n    get groupForm(): boolean;\r\n}\r\n"]}