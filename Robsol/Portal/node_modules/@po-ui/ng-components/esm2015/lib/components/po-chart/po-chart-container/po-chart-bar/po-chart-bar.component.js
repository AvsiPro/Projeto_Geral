import { Component } from '@angular/core';
import { PoChartPlotAreaPaddingTop } from './../../helpers/po-chart-default-values.constant';
import { PoChartBarBaseComponent } from './po-chart-bar-base.component';
import { PoChartMathsService } from './../../services/po-chart-maths.service';
export class PoChartBarComponent extends PoChartBarBaseComponent {
    constructor(mathsService) {
        super(mathsService);
        this.mathsService = mathsService;
        this.tooltipPosition = 'right';
    }
    barCoordinates(seriesIndex, serieItemDataIndex, containerSize, minMaxSeriesValues, serieValue) {
        const { svgPlottingAreaWidth, barHeight, spaceBetweenBars } = this.calculateElementsMeasurements(containerSize);
        const { x1, x2 } = this.xCoordinates(minMaxSeriesValues, svgPlottingAreaWidth, containerSize.axisXLabelWidth, containerSize.svgWidth, serieValue);
        const { y1, y2 } = this.yCoordinates(seriesIndex, serieItemDataIndex, containerSize.svgPlottingAreaHeight, barHeight, spaceBetweenBars);
        return ['M', x1, y2, 'L', x2, y2, 'L', x2, y1, 'L', x1, y1, 'z'].join(' ');
    }
    calculateElementsMeasurements(containerSize) {
        const { svgWidth, svgPlottingAreaHeight, axisXLabelWidth } = containerSize;
        // Fração das séries em relação à largura da categoria. Incrementa + 2 na extensão das séries pois se trata da área de margem entre as categorias.
        const svgPlottingAreaWidth = svgWidth - axisXLabelWidth;
        const categoryHeight = svgPlottingAreaHeight / this.seriesGreaterLength;
        const columnFraction = categoryHeight / (this.series.length + 2);
        // Área entre as colunas: retorna zero se houver apenas uma série.
        const spaceBetweenBars = this.series.length > 1 ? columnFraction / (this.series.length + 2) : 0;
        // Subtrai a fração das séries pelo espaço entre as colunas.
        const barHeight = columnFraction - (spaceBetweenBars * (this.series.length - 1)) / (this.series.length + 2);
        return { svgPlottingAreaWidth, barHeight, spaceBetweenBars };
    }
    xCoordinates(minMaxSeriesValues, svgPlottingAreaWidth, axisXLabelWidth, svgWidth, serieValue) {
        const { minValue } = minMaxSeriesValues;
        const valueZeroPercentage = this.mathsService.getSeriePercentage(minMaxSeriesValues, minValue < 0 ? 0 : minValue);
        const x1 = axisXLabelWidth + (svgWidth - axisXLabelWidth) * valueZeroPercentage;
        const xRatio = this.mathsService.getSeriePercentage(minMaxSeriesValues, serieValue);
        const x2 = Math.round(svgPlottingAreaWidth * xRatio + axisXLabelWidth);
        return { x1, x2 };
    }
    yCoordinates(seriesIndex, serieItemDataIndex, svgPlottingAreaHeight, barHeight, spaceBetweenBars) {
        const spaceBetweenAxisAndBars = barHeight;
        const yRatio = serieItemDataIndex / this.seriesGreaterLength;
        const y1 = Math.round(PoChartPlotAreaPaddingTop +
            svgPlottingAreaHeight * yRatio +
            spaceBetweenAxisAndBars +
            barHeight * seriesIndex +
            spaceBetweenBars * seriesIndex);
        const y2 = Math.round(y1 + barHeight);
        return { y1, y2 };
    }
}
PoChartBarComponent.decorators = [
    { type: Component, args: [{
                selector: '[po-chart-bar]',
                template: "<svg:g>\r\n  <svg:g *ngFor=\"let item of seriesPathsCoordinates; let i = index; trackBy: trackBy\"\r\n    [class]=\"'po-chart-bar-group-' + i\"\r\n  >\r\n    <!-- SERIES PATHS -->\r\n    <svg:g po-chart-bar-path\r\n      [attr.key]=\"'po-chart-bar-path-' + i\"\r\n      [p-color]=\"item[0]?.color\" \r\n      [p-coordinates]=\"item\"\r\n      [p-tooltip-position]=\"tooltipPosition\"\r\n      (p-bar-click)=\"onSerieBarClick($event)\"\r\n      (p-bar-hover)=\"onSerieBarHover($event)\"\r\n      >\r\n      </svg:g>\r\n  </svg:g>\r\n</svg:g>"
            },] }
];
PoChartBarComponent.ctorParameters = () => [
    { type: PoChartMathsService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tY2hhcnQtYmFyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3VpL3NyYy9saWIvY29tcG9uZW50cy9wby1jaGFydC9wby1jaGFydC1jb250YWluZXIvcG8tY2hhcnQtYmFyL3BvLWNoYXJ0LWJhci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUUxQyxPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSxrREFBa0QsQ0FBQztBQUU3RixPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUN4RSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSx5Q0FBeUMsQ0FBQztBQVM5RSxNQUFNLE9BQU8sbUJBQW9CLFNBQVEsdUJBQXVCO0lBRzlELFlBQXNCLFlBQWlDO1FBQ3JELEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQztRQURBLGlCQUFZLEdBQVosWUFBWSxDQUFxQjtRQUY5QyxvQkFBZSxHQUFHLE9BQU8sQ0FBQztJQUluQyxDQUFDO0lBRVMsY0FBYyxDQUN0QixXQUFtQixFQUNuQixrQkFBMEIsRUFDMUIsYUFBbUMsRUFDbkMsa0JBQXVDLEVBQ3ZDLFVBQWtCO1FBRWxCLE1BQU0sRUFBRSxvQkFBb0IsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyxJQUFJLENBQUMsNkJBQTZCLENBQUMsYUFBYSxDQUFDLENBQUM7UUFFaEgsTUFBTSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUNsQyxrQkFBa0IsRUFDbEIsb0JBQW9CLEVBQ3BCLGFBQWEsQ0FBQyxlQUFlLEVBQzdCLGFBQWEsQ0FBQyxRQUFRLEVBQ3RCLFVBQVUsQ0FDWCxDQUFDO1FBQ0YsTUFBTSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsR0FBRyxJQUFJ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QUFHLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxHQUFHLFNBQVMsQ0FBQyxDQUFDO1FBQ3RDLE9BQU8sRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUM7SUFDcEIsQ0FBQzs7O1lBNUZGLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsZ0JBQWdCO2dCQUMxQix3aUJBQTJDO2FBQzVDOzs7WUFSUSxtQkFBbUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbmltcG9ydCB7IFBvQ2hhcnRQbG90QXJlYVBhZGRpbmdUb3AgfSBmcm9tICcuLy4uLy4uL2hlbHBlcnMvcG8tY2hhcnQtZGVmYXVsdC12YWx1ZXMuY29uc3RhbnQnO1xyXG5cclxuaW1wb3J0IHsgUG9DaGFydEJhckJhc2VDb21wb25lbnQgfSBmcm9tICcuL3BvLWNoYXJ0LWJhci1iYXNlLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IFBvQ2hhcnRNYXRoc1NlcnZpY2UgfSBmcm9tICcuLy4uLy4uL3NlcnZpY2VzL3BvLWNoYXJ0LW1hdGhzLnNlcnZpY2UnO1xyXG5cclxuaW1wb3J0IHsgUG9DaGFydENvbnRhaW5lclNpemUgfSBmcm9tICcuLy4uLy4uL2ludGVyZmFjZXMvcG8tY2hhcnQtY29udGFpbmVyLXNpemUuaW50ZXJmYWNlJztcclxuaW1wb3J0IHsgUG9DaGFydE1pbk1heFZhbHVlcyB9IGZyb20gJy4vLi4vLi4vaW50ZXJmYWNlcy9wby1jaGFydC1taW4tbWF4LXZhbHVlcy5pbnRlcmZhY2UnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdbcG8tY2hhcnQtYmFyXScsXHJcbiAgdGVtcGxhdGVVcmw6ICcuL3BvLWNoYXJ0LWJhci5jb21wb25lbnQuc3ZnJ1xyXG59KVxyXG5leHBvcnQgY2xhc3MgUG9DaGFydEJhckNvbXBvbmVudCBleHRlbmRzIFBvQ2hhcnRCYXJCYXNlQ29tcG9uZW50IHtcclxuICByZWFkb25seSB0b29sdGlwUG9zaXRpb24gPSAncmlnaHQnO1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgbWF0aHNTZXJ2aWNlOiBQb0NoYXJ0TWF0aHNTZXJ2aWNlKSB7XHJcbiAgICBzdXBlcihtYXRoc1NlcnZpY2UpO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIGJhckNvb3JkaW5hdGVzKFxyXG4gICAgc2VyaWVzSW5kZXg6IG51bWJlcixcclxuICAgIHNlcmllSXRlbURhdGFJbmRleDogbnVtYmVyLFxyXG4gICAgY29udGFpbmVyU2l6ZTogUG9DaGFydENvbnRhaW5lclNpemUsXHJcbiAgICBtaW5NYXhTZXJpZXNWYWx1ZXM6IFBvQ2hhcnRNaW5NYXhWYWx1ZXMsXHJcbiAgICBzZXJpZVZhbHVlOiBudW1iZXJcclxuICApIHtcclxuICAgIGNvbnN0IHsgc3ZnUGxvdHRpbmdBcmVhV2lkdGgsIGJhckhlaWdodCwgc3BhY2VCZXR3ZWVuQmFycyB9ID0gdGhpcy5jYWxjdWxhdGVFbGVtZW50c01lYXN1cmVtZW50cyhjb250YWluZXJTaXplKTtcclxuXHJcbiAgICBjb25zdCB7IHgxLCB4MiB9ID0gdGhpcy54Q29vcmRpbmF0ZXMoXHJcbiAgICAgIG1pbk1heFNlcmllc1ZhbHVlcyxcclxuICAgICAgc3ZnUGxvdHRpbmdBcmVhV2lkdGgsXHJcbiAgICAgIGNvbnRhaW5lclNpemUuYXhpc1hMYWJlbFdpZHRoLFxyXG4gICAgICBjb250YWluZXJTaXplLnN2Z1dpZHRoLFxyXG4gICAgICBzZXJpZVZhbHVlXHJcbiAgICApO1xyXG4gICAgY29uc3QgeyB5MSwgeTIgfSA9IHRoaXMueUNvb3JkaW5hdGVzKFxyXG4gICAgICBzZXJpZXNJbmRleCxcclxuICAgICAgc2VyaWVJdGVtRGF0YUluZGV4LFxyXG4gICAgICBjb250YWluZXJTaXplLnN2Z1Bsb3R0aW5nQXJlYUhlaWdodCxcclxuICAgICAgYmFySGVpZ2h0LFxyXG4gICAgICBzcGFjZUJldHdlZW5CYXJzXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiBbJ00nLCB4MSwgeTIsICdMJywgeDIsIHkyLCAnTCcsIHgyLCB5MSwgJ0wnLCB4MSwgeTEsICd6J10uam9pbignICcpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjYWxjdWxhdGVFbGVtZW50c01lYXN1cmVtZW50cyhjb250YWluZXJTaXplOiBQb0NoYXJ0Q29udGFpbmVyU2l6ZSkge1xyXG4gICAgY29uc3QgeyBzdmdXaWR0aCwgc3ZnUGxvdHRpbmdBcmVhSGVpZ2h0LCBheGlzWExhYmVsV2lkdGggfSA9IGNvbnRhaW5lclNpemU7XHJcblxyXG4gICAgLy8gRnJhw6fDo28gZGFzIHPDqXJpZXMgZW0gcmVsYcOnw6NvIMOgIGxhcmd1cmEgZGEgY2F0ZWdvcmlhLiBJbmNyZW1lbnRhICsgMiBuYSBleHRlbnPDo28gZGFzIHPDqXJpZXMgcG9pcyBzZSB0cmF0YSBkYSDDoXJlYSBkZSBtYXJnZW0gZW50cmUgYXMgY2F0ZWdvcmlhcy5cclxuICAgIGNvbnN0IHN2Z1Bsb3R0aW5nQXJlYVdpZHRoID0gc3ZnV2lkdGggLSBheGlzWExhYmVsV2lkdGg7XHJcbiAgICBjb25zdCBjYXRlZ29yeUhlaWdodCA9IHN2Z1Bsb3R0aW5nQXJlYUhlaWdodCAvIHRoaXMuc2VyaWVzR3JlYXRlckxlbmd0aDtcclxuICAgIGNvbnN0IGNvbHVtbkZyYWN0aW9uID0gY2F0ZWdvcnlIZWlnaHQgLyAodGhpcy5zZXJpZXMubGVuZ3RoICsgMik7XHJcblxyXG4gICAgLy8gw4FyZWEgZW50cmUgYXMgY29sdW5hczogcmV0b3JuYSB6ZXJvIHNlIGhvdXZlciBhcGVuYXMgdW1hIHPDqXJpZS5cclxuICAgIGNvbnN0IHNwYWNlQmV0d2VlbkJhcnMgPSB0aGlzLnNlcmllcy5sZW5ndGggPiAxID8gY29sdW1uRnJhY3Rpb24gLyAodGhpcy5zZXJpZXMubGVuZ3RoICsgMikgOiAwO1xyXG5cclxuICAgIC8vIFN1YnRyYWkgYSBmcmHDp8OjbyBkYXMgc8OpcmllcyBwZWxvIGVzcGHDp28gZW50cmUgYXMgY29sdW5hcy5cclxuICAgIGNvbnN0IGJhckhlaWdodCA9IGNvbHVtbkZyYWN0aW9uIC0gKHNwYWNlQmV0d2VlbkJhcnMgKiAodGhpcy5zZXJpZXMubGVuZ3RoIC0gMSkpIC8gKHRoaXMuc2VyaWVzLmxlbmd0aCArIDIpO1xyXG5cclxuICAgIHJldHVybiB7IHN2Z1Bsb3R0aW5nQXJlYVdpZHRoLCBiYXJIZWlnaHQsIHNwYWNlQmV0d2VlbkJhcnMgfTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgeENvb3JkaW5hdGVzKFxyXG4gICAgbWluTWF4U2VyaWVzVmFsdWVzOiBQb0NoYXJ0TWluTWF4VmFsdWVzLFxyXG4gICAgc3ZnUGxvdHRpbmdBcmVhV2lkdGg6IG51bWJlcixcclxuICAgIGF4aXNYTGFiZWxXaWR0aDogUG9DaGFydENvbnRhaW5lclNpemVbJ2F4aXNYTGFiZWxXaWR0aCddLFxyXG4gICAgc3ZnV2lkdGg6IFBvQ2hhcnRDb250YWluZXJTaXplWydzdmdXaWR0aCddLFxyXG4gICAgc2VyaWVWYWx1ZTogbnVtYmVyXHJcbiAgKSB7XHJcbiAgICBjb25zdCB7IG1pblZhbHVlIH0gPSBtaW5NYXhTZXJpZXNWYWx1ZXM7XHJcbiAgICBjb25zdCB2YWx1ZVplcm9QZXJjZW50YWdlID0gdGhpcy5tYXRoc1NlcnZpY2UuZ2V0U2VyaWVQZXJjZW50YWdlKG1pbk1heFNlcmllc1ZhbHVlcywgbWluVmFsdWUgPCAwID8gMCA6IG1pblZhbHVlKTtcclxuICAgIGNvbnN0IHgxID0gYXhpc1hMYWJlbFdpZHRoICsgKHN2Z1dpZHRoIC0gYXhpc1hMYWJlbFdpZHRoKSAqIHZhbHVlWmVyb1BlcmNlbnRhZ2U7XHJcblxyXG4gICAgY29uc3QgeFJhdGlvID0gdGhpcy5tYXRoc1NlcnZpY2UuZ2V0U2VyaWVQZXJjZW50YWdlKG1pbk1heFNlcmllc1ZhbHVlcywgc2VyaWVWYWx1ZSk7XHJcbiAgICBjb25zdCB4MiA9IE1hdGgucm91bmQoc3ZnUGxvdHRpbmdBcmVhV2lkdGggKiB4UmF0aW8gKyBheGlzWExhYmVsV2lkdGgpO1xyXG5cclxuICAgIHJldHVybiB7IHgxLCB4MiB9O1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSB5Q29vcmRpbmF0ZXMoXHJcbiAgICBzZXJpZXNJbmRleDogbnVtYmVyLFxyXG4gICAgc2VyaWVJdGVtRGF0YUluZGV4OiBudW1iZXIsXHJcbiAgICBzdmdQbG90dGluZ0FyZWFIZWlnaHQ6IG51bWJlcixcclxuICAgIGJhckhlaWdodDogbnVtYmVyLFxyXG4gICAgc3BhY2VCZXR3ZWVuQmFyczogbnVtYmVyXHJcbiAgKSB7XHJcbiAgICBjb25zdCBzcGFjZUJldHdlZW5BeGlzQW5kQmFycyA9IGJhckhlaWdodDtcclxuICAgIGNvbnN0IHlSYXRpbyA9IHNlcmllSXRlbURhdGFJbmRleCAvIHRoaXMuc2VyaWVzR3JlYXRlckxlbmd0aDtcclxuXHJcbiAgICBjb25zdCB5MSA9IE1hdGgucm91bmQoXHJcbiAgICAgIFBvQ2hhcnRQbG90QXJlYVBhZGRpbmdUb3AgK1xyXG4gICAgICAgIHN2Z1Bsb3R0aW5nQXJlYUhlaWdodCAqIHlSYXRpbyArXHJcbiAgICAgICAgc3BhY2VCZXR3ZWVuQXhpc0FuZEJhcnMgK1xyXG4gICAgICAgIGJhckhlaWdodCAqIHNlcmllc0luZGV4ICtcclxuICAgICAgICBzcGFjZUJldHdlZW5CYXJzICogc2VyaWVzSW5kZXhcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgeTIgPSBNYXRoLnJvdW5kKHkxICsgYmFySGVpZ2h0KTtcclxuICAgIHJldHVybiB7IHkxLCB5MiB9O1xyXG4gIH1cclxufVxyXG4iXX0=