(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('localforage'), require('custom-idle-queue'), require('lokijs'), require('lokijs/src/loki-indexed-adapter')) :
    typeof define === 'function' && define.amd ? define('@po-ui/ng-storage', ['exports', '@angular/core', 'localforage', 'custom-idle-queue', 'lokijs', 'lokijs/src/loki-indexed-adapter'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['po-ui'] = global['po-ui'] || {}, global['po-ui']['ng-storage'] = {}), global.ng.core, global.LocalForage, global.IdleQueue, global.Loki, global.LokiIndexedAdapter));
}(this, (function (exports, core, LocalForage, IdleQueue, Loki, LokiIndexedAdapter) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var LocalForage__namespace = /*#__PURE__*/_interopNamespace(LocalForage);
    var IdleQueue__default = /*#__PURE__*/_interopDefaultLegacy(IdleQueue);
    var Loki__default = /*#__PURE__*/_interopDefaultLegacy(Loki);
    var LokiIndexedAdapter__default = /*#__PURE__*/_interopDefaultLegacy(LokiIndexedAdapter);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || Array.prototype.slice.call(from));
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    var keyField = 'key';
    var PoLokiDriver = /** @class */ (function () {
        function PoLokiDriver() {
            var self = this;
            this.driver = {
                _driver: 'lokijs',
                _initStorage: function (options) {
                    return self.initStorage(options);
                },
                clear: function () {
                    return self.clear(this);
                },
                getItem: function (key) {
                    return self.getItem(this, key);
                },
                iterate: function (iteratorCallback) {
                    return self.iterate(this, iteratorCallback);
                },
                key: function (n) {
                    return self.key(this, n);
                },
                keys: function () {
                    return self.keys(this);
                },
                length: function () {
                    return self.length(this);
                },
                removeItem: function (key) {
                    return self.removeItem(this, key);
                },
                setItem: function (key, value) {
                    return self.setItem(this, key, value);
                }
            };
        }
        // Funções de iteração
        PoLokiDriver.prototype.clear = function (localforage) {
            var _this = this;
            return new Promise(function (resolve) {
                localforage.ready().then(function () {
                    if (_this.hasCollectionAndDataInCollection()) {
                        _this.clearCollection();
                    }
                    resolve(null);
                });
            });
        };
        PoLokiDriver.prototype.getItem = function (localforage, key) {
            var _this = this;
            return new Promise(function (resolve) {
                localforage.ready().then(function () {
                    if (_this.hasCollectionAndDataInCollection()) {
                        var item = _this.getItemInCollectionBy(keyField, key);
                        if (item) {
                            resolve(item.value);
                        }
                    }
                    resolve(null);
                });
            });
        };
        PoLokiDriver.prototype.initStorage = function (options) {
            var _this = this;
            return new Promise(function (resolve) {
                try {
                    _this.configureLokiStorage(options, _this.databaseInitialize.bind(_this, options, resolve));
                }
                catch (_a) {
                    throw new Error("Cannot configure Loki Storage");
                }
            });
        };
        PoLokiDriver.prototype.iterate = function (localforage, iteratorCallback) {
            var _this = this;
            return new Promise(function (resolve) {
                localforage.ready().then(function () {
                    if (_this.hasCollectionAndDataInCollection()) {
                        _this.iterateWithDataItem(iteratorCallback);
                    }
                    resolve(null);
                });
            });
        };
        PoLokiDriver.prototype.key = function (localforage, n) {
            var _this = this;
            return new Promise(function (resolve) {
                localforage.ready().then(function () {
                    if (_this.hasCollection()) {
                        var map = _this.getLokiMap();
                        resolve(map[n]);
                    }
                    resolve(null);
                });
            });
        };
        PoLokiDriver.prototype.keys = function (localforage) {
            var _this = this;
            return new Promise(function (resolve) {
                localforage.ready().then(function () {
                    var e_1, _b;
                    if (_this.hasCollection()) {
                        var keys = [];
                        var map = _this.getLokiMap();
                        try {
                            for (var _c = __values(Object.keys(map)), _d = _c.next(); !_d.done; _d = _c.next()) {
                                var key = _d.value;
                                keys.push(map[key]);
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                        resolve(keys);
                    }
                    resolve(null);
                });
            });
        };
        PoLokiDriver.prototype.length = function (localforage) {
            var _this = this;
            return new Promise(function (resolve) {
                localforage.ready().then(function () {
                    if (_this.hasCollection()) {
                        resolve(_this.getNumberItensInCollection());
                    }
                    resolve(0);
                });
            });
        };
        PoLokiDriver.prototype.removeItem = function (localforage, key) {
            var _this = this;
            return new Promise(function (resolve) {
                localforage.ready().then(function () {
                    if (_this.hasCollection()) {
                        _this.findAndRemoveItem(key);
                    }
                    resolve(null);
                });
            });
        };
        PoLokiDriver.prototype.setItem = function (localforage, key, value) {
            var _this = this;
            return new Promise(function (resolve) {
                localforage.ready().then(function () {
                    if (_this.hasCollection()) {
                        var item = void 0;
                        if (_this.hasDataInCollection()) {
                            item = _this.getItemInCollectionBy(keyField, key);
                        }
                        _this.insertOrUpdate(item, value, key);
                    }
                    resolve(value);
                });
            });
        };
        // Funções de acesso ao storage
        // eslint-disable-next-line @typescript-eslint/member-ordering
        PoLokiDriver.prototype.getDriver = function () {
            return this.driver;
        };
        PoLokiDriver.prototype.addCollection = function (options) {
            return this.db.addCollection(options.storeName, { unique: [keyField] });
        };
        PoLokiDriver.prototype.clearCollection = function () {
            this.collection.clear({ removeIndices: false });
        };
        PoLokiDriver.prototype.configureLokiStorage = function (options, databaseInitialize) {
            var idbAdapter = new LokiIndexedAdapter__default['default']();
            this.db = new Loki__default['default'](options.name, {
                adapter: idbAdapter,
                autoload: true,
                autoloadCallback: databaseInitialize,
                autosave: true,
                autosaveInterval: 4000
            });
        };
        PoLokiDriver.prototype.findAndRemoveItem = function (key) {
            var _b;
            this.collection.findAndRemove((_b = {}, _b[keyField] = key, _b));
        };
        PoLokiDriver.prototype.getCollection = function (options) {
            return this.db.getCollection(options.storeName);
        };
        PoLokiDriver.prototype.databaseInitialize = function (options, resolve) {
            this.collection = this.getCollection(options);
            if (!this.hasCollection()) {
                this.collection = this.addCollection(options);
            }
            resolve();
        };
        PoLokiDriver.prototype.getItemInCollectionBy = function (fieldKey, key) {
            return this.collection.by(fieldKey, key);
        };
        PoLokiDriver.prototype.getLokiMap = function () {
            return this.collection.constraints.unique[keyField].lokiMap;
        };
        PoLokiDriver.prototype.hasCollection = function () {
            return this.collection;
        };
        PoLokiDriver.prototype.hasDataInCollection = function () {
            return this.collection.data && this.collection.data.length;
        };
        PoLokiDriver.prototype.hasCollectionAndDataInCollection = function () {
            return this.hasCollection() && this.hasDataInCollection();
        };
        PoLokiDriver.prototype.insertOrUpdate = function (item, value, key) {
            var _b;
            if (item) {
                item.value = value;
                this.collection.update(item);
            }
            else {
                this.collection.insert((_b = {}, _b[keyField] = key, _b.value = value, _b));
            }
        };
        PoLokiDriver.prototype.iterateWithDataItem = function (iteratorcallback) {
            this.collection.data.forEach(function (element) {
                iteratorcallback(element.value, element[keyField], element.$loki);
            });
        };
        PoLokiDriver.prototype.getNumberItensInCollection = function () {
            return this.collection.count();
        };
        return PoLokiDriver;
    }());

    var PO_STORAGE_CONFIG_TOKEN = new core.InjectionToken('PO_STORAGE_CONFIG_TOKEN');
    /**
     * @description
     *
     * O PO Storage é uma biblioteca que fornece um serviço para armazenamento de dados no dispositivo local, sendo semelhante
     * ao funcionamento do [IonicStorage](https://ionicframework.com/docs/storage/).
     * É possível utilizar os drivers [Websql](https://dev.w3.org/html5/webdatabase/), [Indexeddb](https://www.w3.org/TR/IndexedDB/),
     * [LocalStorage](https://html.spec.whatwg.org/multipage/webstorage.html) e também [LokiJS](https://github.com/techfort/LokiJS/wiki).
     *
     * Para um melhor ganho de performance ao buscar e salvar dados, recomendamos a utilização do `LokiJS`, um *database*
     * orientado a documento semelhante ao MongoDB, que além de permitir a persistência dos dados no dispositivo possibilita
     * também o armazenamento dos dados em memória. Outra vantagem, é o aumento do limite de armazenamento para
     * aproximadamente `300mb`.
     *
     * A estrutura utilizada para armazenar os dados é a de chave/valor, onde uma chave funciona como um identificador exclusivo.
     *
     * #### Instalando o PO Storage
     *
     * Para instalar o `po-storage` em sua aplicação execute o seguinte comando:
     *
     * ```shell
     * ng add @po-ui/ng-storage
     * ```
     * Será instalado o pacote `@po-ui/ng-storage` e também já importará `PoStorageModule` no módulo principal da sua aplicação, conforme abaixo:
     *
     * ```typescript
     * import { PoStorageModule } from '@po-ui/ng-storage';
     *
     * @NgModule({
     *  declarations: [...],
     *  imports: [
     *    // Importação do módulo PoStorageModule
     *    PoStorageModule.forRoot(),
     *  ],
     *  bootstrap: [IonicApp],
     *  providers: [...]
     * })
     * export class AppModule {}
     * ```
     *
     * Com a declaração do módulo, é criada uma base de dados no armazenamento local e o serviço `PoStorageService` estará
     * pronto para ser utilizada na sua aplicação.
     *
     * #### Configurando as opções de armazenamento
     *
     * Na importação do módulo, o método `PoStorageModule.forRoot()` pode receber como parâmetro um objeto do tipo
     * [`PoStorageConfig`](documentation/po-storage#po-storage-config),
     * que serve para configurar as opções personalizadas do armazenamento, como por exemplo: o tipo de armazenamento
     * preferêncial.
     *
     * Caso não seja passada nenhuma configuração a ordem padrão será: ['websql', 'indexeddb', 'localstorage', 'lokijs'].
     *
     * Abaixo segue um exemplo de configuração onde o storage preferencial passa a ser o `lokijs`:
     *
     * ```typescript
     * import { PoStorageModule } from '@po-ui/ng-storage';
     *
     * @NgModule({
     *  declarations: [...],
     *  imports: [
     *    // Importação do módulo PoStorageModule com a configuração personalizada
     *    PoStorageModule.forRoot({
     *      name: 'mystorage',
     *      storeName: '_mystore',
     *      driverOrder: ['lokijs', 'websql', 'indexeddb', 'localstorage']
     *    }),
     *  ],
     *  bootstrap: [IonicApp],
     *  providers: [...]
     * })
     * export class AppModule {}
     * ```
     */
    var PoStorageService = /** @class */ (function () {
        function PoStorageService(config) {
            this.driver = null;
            this.idleQueue = new IdleQueue__default['default']();
            this.lokijsDriver = new PoLokiDriver();
            this.setStoragePromise(config);
        }
        /**
         * Retorna a configuração padrão para o armazenamento. Caso nenhuma configuração seja inserida,
         * essa configuração será utilizada.
         *
         * @returns {PoStorageConfig} Objeto com a configuração padrão do armazenamento.
         */
        PoStorageService.getDefaultConfig = function () {
            return {
                name: '_postorage',
                storeName: '_pokv',
                driverOrder: ['websql', 'indexeddb', 'localstorage', 'lokijs']
            };
        };
        /**
         * Cria uma instância do `PoStorageService` com a configuração de armazenamento passada como parâmetro.
         *
         * @param {PoStorageConfig} storageConfig Configuração para o armazenamento.
         * @returns {PoStorageService} Instância do `PoStorageService`.
         */
        PoStorageService.providePoStorage = function (storageConfig) {
            return new PoStorageService(PoStorageService.getConfig(storageConfig));
        };
        PoStorageService.getConfig = function (storageConfig) {
            return storageConfig || PoStorageService.getDefaultConfig();
        };
        /**
         * Busca uma lista armazenada pela chave e concatena com a lista passada por parâmetro.
         *
         * Por exemplo:
         *
         * ``` typescript
         * const clients = [ { name: 'Marie', age: 23 }, { name: 'Pether', age: 39 }];
         *
         * this.poStorageService.set('clientKey', clients).then(() => {});
         *
         * ...
         *
         * const newClients = [ { name: 'Lisa', age: 36 }, { name: 'Bruce', age: 18 } ];
         *
         * this.poStorageService.appendArrayToArray('clientKey', newClients).then(() => {
         *   // A lista agora será:
         *   // [ { name: 'Marie', age: 23 }, { name: 'Pether', age: 39 }, { name: 'Lisa', age: 36 }, { name: 'Bruce', age: 18 }];
         * });
         * ```
         *
         * @param {string} key Chave da lista armazenada.
         * @param {Array} value Lista que será concatenada.
         *
         * @returns {Promise<any>} Promessa que é resolvida após as duas listas serem concatenadas e armazenadas localmente.
         */
        PoStorageService.prototype.appendArrayToArray = function (key, value) {
            return __awaiter(this, void 0, void 0, function () {
                var data, newData;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.getArrayOfStorage(key)];
                        case 1:
                            data = _b.sent();
                            newData = __spreadArray(__spreadArray([], __read(data)), __read(value));
                            return [2 /*return*/, this.set(key, newData)];
                    }
                });
            });
        };
        /**
         * Acrescenta um item em uma lista armazenada pela chave.
         *
         * @param {string} key Chave da lista armazenada.
         * @param {Array} value Item que será acrescentado na lista.
         *
         * @returns {Promise<any>} Promessa que é resolvida após o item ser acrescentado na lista armazenada.
         */
        PoStorageService.prototype.appendItemToArray = function (key, value) {
            return __awaiter(this, void 0, void 0, function () {
                var data;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.getArrayOfStorage(key)];
                        case 1:
                            data = _b.sent();
                            data.push(value);
                            return [2 /*return*/, this.set(key, data)];
                    }
                });
            });
        };
        /**
         * Remove todos os itens da base de dados local configurada na declaração do módulo `PoStorageModule`.
         *
         * > Utilize este método com cautela, para evitar a perda indesejada de dados.
         *
         * @returns {Promise<void>} Promessa que é resolvida após todos os itens da base de dados local serem removidos.
         */
        PoStorageService.prototype.clear = function () {
            return this.storagePromise.then(function (store) { return store.clear(); });
        };
        /**
         * Verifica se existe um valor dentro de uma determinada chave.
         *
         * @param {string} key Chave que será verificada.
         *
         * @returns {Promise<boolean>} Promessa que é resolvida quando a verificação da existência do valor na chave é concluída.
         */
        PoStorageService.prototype.exists = function (key) {
            return this.get(key).then(function (data) { return Promise.resolve(data !== null); });
        };
        /**
         * Itera sobre todas as chaves armazenadas.
         *
         * @param {any} iteratorCallback Função de `callback` que é chamada a cada iteração, com os seguintes parâmetros:
         * valor, chave e número da iteração.
         *
         * Exemplo de utilização:
         *
         * ``` typescript
         * this.poStorageService.forEach((value: any, key: string, iterationNumber: number) => {
         *   // Iteração sobre cada chave armazenada.
         * });
         * ```
         *
         * @returns {Promise<void>} Promessa que é resolvida após a iteração sobre todas as chaves armazenadas.
         */
        PoStorageService.prototype.forEach = function (iteratorCallback) {
            return this.storagePromise.then(function (store) { return store.iterate(iteratorCallback); });
        };
        /**
         * Retorna o valor armazenado em uma determinada chave.
         *
         * @param {string} key Chave que identifica o item.
         * @param {boolean} lock Define se irá travar a leitura e a escrita da base de dados para não ser acessada de forma paralela.
         * Caso outra leitura/escrita já tenha sido iniciada, este método irá esperar o outro terminar para então começar.
         *
         * Padrão: `false`.
         *
         * > Esta definição só será válida se o outro acesso paralelo a este método também estiver com o parâmetro *lock* ativado.
         * @returns {Promise<any>} Promessa que é resolvida após o item ser buscado.
         */
        PoStorageService.prototype.get = function (key, lock) {
            if (lock === void 0) { lock = false; }
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (!lock) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.requestIdlePromise()];
                        case 1:
                            _b.sent();
                            return [4 /*yield*/, this.idleQueue.wrapCall(function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_b) {
                                        switch (_b.label) {
                                            case 0: return [4 /*yield*/, this.getImmutableItem(key)];
                                            case 1:
                                                _b.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        case 2: return [2 /*return*/, _b.sent()];
                        case 3: return [4 /*yield*/, this.getImmutableItem(key)];
                        case 4: return [2 /*return*/, _b.sent()];
                    }
                });
            });
        };
        /**
         * Retorna o nome do *driver* que está sendo usado para armazenar os dados, por exemplo: localStorage.
         *
         * @returns {string | null} Nome do *driver*.
         */
        PoStorageService.prototype.getDriver = function () {
            return this.driver;
        };
        /**
         * Retorna o primeiro item de uma lista para uma determinada chave.
         *
         * @param {string} key Chave da lista.
         * @returns {Promise<any>} Promessa que é resolvida após o primeiro item ser encontrado.
         */
        PoStorageService.prototype.getFirstItem = function (key) {
            return this.get(key).then(function (data) { return Promise.resolve(data ? data[0] : null); });
        };
        /**
         * Remove o primeiro item de uma lista a partir da chave.
         *
         * @param {string} key Chave da lista que será removido o primeiro item.
         * @returns {Promise<any>} Promessa que é resolvida após o primeiro item da lista ser removido.
         */
        PoStorageService.prototype.getItemAndRemove = function (key) {
            var _this = this;
            return this.get(key).then(function (data) {
                if (data === null) {
                    return null;
                }
                var item = data.shift();
                return _this.set(key, data).then(function () { return Promise.resolve(item); });
            });
        };
        /**
         * Busca o primeiro objeto encontrado dentro de uma lista pelo do valor de um campo.
         *
         * Por exemplo:
         *
         * ``` typescript
         * const clients = [ { name: 'Marie', age: 23 }, { name: 'Pether', age: 39 }];
         *
         * this.poStorageService.set('clientKey', clients).then(() => {});
         *
         * ...
         *
         * this.poStorageService.getItemByField('clientKey', 'name', 'Marie').then(client => {
         *   // Resultado do console.log: { name: 'Marie', age: 23 }
         *   console.log(client);
         * });
         * ```
         *
         * @param {string} key Chave da lista.
         * @param {string} fieldName O campo a ser filtrado.
         * @param {any} fieldValue O valor do campo.
         * @returns {Promise<any>} Promessa que é resolvida com o item que foi encontrado.
         */
        PoStorageService.prototype.getItemByField = function (key, fieldName, fieldValue) {
            return this.get(key).then(function (storageRecords) {
                var storageRecordsFiltered = storageRecords.find(function (storageRecord) { return storageRecord[fieldName] === fieldValue; });
                storageRecordsFiltered = storageRecordsFiltered || null;
                return Promise.resolve(storageRecordsFiltered);
            });
        };
        /**
         * Lista com todas as chaves armazenadas.
         *
         * @returns {Promise<Array<string>>} Promessa que é resolvida com todas as chaves armazenadas.
         */
        PoStorageService.prototype.keys = function () {
            return this.storagePromise.then(function (store) { return store.keys(); });
        };
        /**
         * Quantidade de chaves armazenadas.
         *
         * @returns {Promise<number>} Promessa que é resolvida com o número de chaves armazenadas.
         */
        PoStorageService.prototype.length = function () {
            return this.storagePromise.then(function (store) { return store.length(); });
        };
        /**
         * Utilizado para gerenciar o bloqueio e desbloqueio de recursos no `PoStorageService`.
         * Aguardando a liberação da utilização dos recursos que participam deste comportamento e posteriormente envolve o recurso
         * passado como parâmetro em um comportamento de bloqueio e desbloqueio.
         *
         * Este método se comporta igual a utilização em conjunta dos métodos: `PoStorageService.requestIdlePromise()`,
         * `PoStorageService.lock()` e `PoStorageService.unlook()`.
         *
         * Veja mais no método: [`PoStorage.requestIdlePromise()`](documentation/po-storage#request-idle-promise).
         *
         * @param {Function} limitedResource Função que será envolvida no comportamento de bloqueio e desbloqueio.
         */
        PoStorageService.prototype.limitedCallWrap = function (limitedResource) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.requestIdlePromise()];
                        case 1:
                            _b.sent();
                            return [2 /*return*/, this.idleQueue.wrapCall(limitedResource)];
                    }
                });
            });
        };
        /**
         * Incrementa um valor na fila de bloqueio do `PoStorageService`. Utilizado juntamente com o método `unlock` para poder
         * controlar a execução de uma determinada tarefa com o `PoStorage.requestIdlePromise()`.
         *
         * Veja mais no método: [`PoStorage.requestIdlePromise()`](documentation/po-storage#request-idle-promise).
         */
        PoStorageService.prototype.lock = function () {
            this.idleQueue.lock();
        };
        /**
         * Determina se o processo de inicialização do *driver* assíncrono foi concluído.
         *
         * @returns {Promise<LocalForage>} Promessa que é resolvida quando o processo de inicialização do *driver* assíncrono
         * for concluído.
         */
        PoStorageService.prototype.ready = function () {
            return this.storagePromise;
        };
        /**
         * Remove um valor associado a uma chave.
         *
         * @param {key} key Chave do valor que será removido.
         * @returns {Promise<any>} Promessa que é resolvida após o valor ser removido.
         */
        PoStorageService.prototype.remove = function (key) {
            return this.storagePromise.then(function (store) { return store.removeItem(key); });
        };
        /**
         * Remove uma propriedade de um objeto armazenado.
         *
         * @param {string} key Chave do objeto armazenado.
         * @param {string} property Propriedade que será removida.
         *
         * @returns {Promise<any>} Promessa que é resolvida após a propriedade ser removida.
         */
        PoStorageService.prototype.removeIndexFromObject = function (key, property) {
            return __awaiter(this, void 0, void 0, function () {
                var data;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.getObjectOfStorage(key)];
                        case 1:
                            data = _b.sent();
                            delete data[property];
                            return [2 /*return*/, this.set(key, data)];
                    }
                });
            });
        };
        /**
         * Remove um objeto de uma lista armazenada pelo valor de uma propriedade.
         *
         * Por exemplo:
         *
         * ``` typescript
         * const clients = [ { name: 'Marie', age: 23 }, { name: 'Pether', age: 39 }];
         *
         * this.poStorageService.set('clientKey', clients).then(() => {});
         *
         * ...
         *
         * this.poStorageService.removeItemFromArray('clientKey', 'name', 'Marie').then(() => {
         *   // O objeto { name: 'Marie', age: 23 } foi removido da lista que está na chave 'clientKey'
         * });
         * ```
         *
         * @param {string} key Chave da lista que contém o item que será removido.
         * @param {string} field O campo a ser filtrado no item.
         * @param {string} value O valor do filtro.
         * @returns {Promise<any>} Promessa que é resolvida quando o objeto for removido da lista.
         */
        PoStorageService.prototype.removeItemFromArray = function (key, field, value) {
            return __awaiter(this, void 0, void 0, function () {
                var data;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.getArrayOfStorage(key)];
                        case 1:
                            data = _b.sent();
                            data = data.filter(function (item) { return item[field] !== value; });
                            return [2 /*return*/, this.set(key, data)];
                    }
                });
            });
        };
        /**
         * <a id="request-idle-promise"></a>
         * Método que verifica se o acesso a base de dados configurada está liberado.
         *
         * Utilizado em conjunto com os métodos `lock()` e `unlock()` entre tarefas que não podem ser executadas de forma
         * paralela, para não causar inconsistências nos dados.
         *
         * Exemplo de utilização:
         *
         * ```
         * // Aguarda a liberação para continuar
         * await this.poStorage.requestIdlePromise();
         *
         * this.poStorage.lock();
         *
         * // Executa uma tarefa que irá ler e/ou escrever na base de dados configurada.
         *
         * this.poStorage.unlock();
         * ```
         *
         * > É importante sempre utilizá-lo antes de executar os métodos `lock()` e `unlock()` para garantir que a tarefa só
         * será executada caso o acesso esteja livre.
         *
         * @returns {Promise<any>} Promessa que é resolvida quando o acesso a base de dados configurada estiver liberado.
         */
        PoStorageService.prototype.requestIdlePromise = function () {
            return this.idleQueue.requestIdlePromise();
        };
        /**
         * Grava um valor em uma determinada chave.
         *
         * @param {string} key Chave para o valor que será gravado.
         * @param {any} value Valor que será gravado.
         * @param {boolean} lock Define se irá travar a leitura e a escrita da base de dados para não ser acessada de forma paralela.
         * Caso outra leitura/escrita já tenha sido iniciada, este método irá esperar o outro terminar para então começar.
         *
         * Padrão: `false`.
         *
         * > Esta definição só será válida se o outro acesso paralelo a este método também estiver com o parâmetro *lock* ativado.
         * @returns {Promise<any>} Promessa que é resolvida após o valor ter sido gravado.
         */
        PoStorageService.prototype.set = function (key, value, lock) {
            if (lock === void 0) { lock = false; }
            return __awaiter(this, void 0, void 0, function () {
                var store, newValue;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.storagePromise];
                        case 1:
                            store = _b.sent();
                            newValue = typeof value === 'object' ? JSON.parse(JSON.stringify(value)) : value;
                            if (!lock) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.requestIdlePromise()];
                        case 2:
                            _b.sent();
                            return [2 /*return*/, this.idleQueue.wrapCall(function () { return store.setItem(key, newValue); })];
                        case 3: return [2 /*return*/, store.setItem(key, newValue)];
                    }
                });
            });
        };
        /**
         * Atribui um valor a uma propriedade de um objeto armazenado pela chave.
         *
         * Por exemplo:
         *
         * ``` typescript
         * const clients = [ { name: 'Marie', age: 23 }, { name: 'Pether', age: 39 }];
         *
         * this.poStorageService.set('clientKey', clients).then(() => {});
         *
         * ...
         *
         * this.poStorageService.setIndexToObject('clientKey', 'name', 'Clare').then(() => {
         *   // O objeto { name: 'Marie', age: 23 } passa a ser { name: 'Clare', age: 23 }
         * });
         * ```
         *
         * @param {string} key Chave do objeto.
         * @param {string} property Nome da propriedade do objeto.
         * @param {any} value Valor que será gravado na propriedade do objeto.
         */
        PoStorageService.prototype.setIndexToObject = function (key, property, value) {
            return __awaiter(this, void 0, void 0, function () {
                var data;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.getObjectOfStorage(key)];
                        case 1:
                            data = _b.sent();
                            data[property] = value;
                            return [2 /*return*/, this.set(key, data)];
                    }
                });
            });
        };
        /**
         * Decrementa um valor na fila de bloqueio. Utilizado juntamente com o método `lock` para poder
         * controlar a execução de uma determinada tarefa com o `PoStorage.requestIdlePromise()`.
         *
         * Veja mais no método: [`PoStorage.requestIdlePromise()`](documentation/po-storage#request-idle-promise).
         */
        PoStorageService.prototype.unlock = function () {
            this.idleQueue.unlock();
        };
        PoStorageService.prototype.getArrayOfStorage = function (key) {
            return __awaiter(this, void 0, void 0, function () {
                var data;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.get(key)];
                        case 1:
                            data = _b.sent();
                            return [2 /*return*/, data || []];
                    }
                });
            });
        };
        PoStorageService.prototype.getImmutableItem = function (key) {
            return __awaiter(this, void 0, void 0, function () {
                var store, items;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.storagePromise];
                        case 1:
                            store = _b.sent();
                            return [4 /*yield*/, store.getItem(key)];
                        case 2:
                            items = _b.sent();
                            return [2 /*return*/, items ? JSON.parse(JSON.stringify(items)) : null];
                    }
                });
            });
        };
        PoStorageService.prototype.defineLocalForageDriver = function (localForageInstance, driverOrder) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, localForageInstance.defineDriver(this.lokijsDriver.getDriver())];
                        case 1:
                            _b.sent();
                            return [4 /*yield*/, this.setDriver(localForageInstance, driverOrder)];
                        case 2:
                            _b.sent();
                            return [2 /*return*/, localForageInstance];
                    }
                });
            });
        };
        PoStorageService.prototype.getDriverOrder = function (driverOrder) {
            return driverOrder.map(function (driver) {
                switch (driver) {
                    case 'indexeddb':
                        return LocalForage__namespace.INDEXEDDB;
                    case 'websql':
                        return LocalForage__namespace.WEBSQL;
                    case 'localstorage':
                        return LocalForage__namespace.LOCALSTORAGE;
                    default:
                        return driver;
                }
            });
        };
        PoStorageService.prototype.getObjectOfStorage = function (key) {
            return __awaiter(this, void 0, void 0, function () {
                var data;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.get(key)];
                        case 1:
                            data = _b.sent();
                            return [2 /*return*/, data || {}];
                    }
                });
            });
        };
        PoStorageService.prototype.setDriver = function (localForageInstance, driverOrder) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, localForageInstance.setDriver(this.getDriverOrder(driverOrder))];
                        case 1:
                            _b.sent();
                            this.driver = localForageInstance.driver();
                            return [2 /*return*/];
                    }
                });
            });
        };
        PoStorageService.prototype.setStoragePromise = function (config) {
            this.storagePromise = this.getStorageInstance(config);
        };
        PoStorageService.prototype.getStorageInstance = function (config) {
            return __awaiter(this, void 0, void 0, function () {
                var defaultConfig, actualConfig, localForageInstance, _a_1;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            defaultConfig = PoStorageService.getDefaultConfig();
                            actualConfig = Object.assign(defaultConfig, config || {});
                            localForageInstance = LocalForage__namespace.createInstance(actualConfig);
                            _b.label = 1;
                        case 1:
                            _b.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.defineLocalForageDriver(localForageInstance, actualConfig.driverOrder)];
                        case 2: return [2 /*return*/, _b.sent()];
                        case 3:
                            _a_1 = _b.sent();
                            throw new Error("Cannot use this drivers: " + actualConfig.driverOrder.join(', ') + ".");
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        return PoStorageService;
    }());
    PoStorageService.decorators = [
        { type: core.Injectable }
    ];
    PoStorageService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [PO_STORAGE_CONFIG_TOKEN,] }] }
    ]; };

    /**
     * @description
     *
     * Módulo do componente PoStorage responsável por manipular o storage do browser.
     */
    var PoStorageModule = /** @class */ (function () {
        function PoStorageModule() {
        }
        PoStorageModule.forRoot = function (storageConfig) {
            return {
                ngModule: PoStorageModule,
                providers: [
                    {
                        provide: PO_STORAGE_CONFIG_TOKEN,
                        useValue: storageConfig || PoStorageService.getDefaultConfig()
                    },
                    {
                        provide: PoStorageService,
                        useFactory: PoStorageService.providePoStorage,
                        deps: [PO_STORAGE_CONFIG_TOKEN]
                    }
                ]
            };
        };
        return PoStorageModule;
    }());
    PoStorageModule.decorators = [
        { type: core.NgModule }
    ];

    /**
     * Generated bundle index. Do not edit.
     */

    exports.PoStorageModule = PoStorageModule;
    exports.PoStorageService = PoStorageService;
    exports.ɵa = PO_STORAGE_CONFIG_TOKEN;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=po-ui-ng-storage.umd.js.map
