import { __awaiter } from "tslib";
import { Inject, Injectable, InjectionToken } from '@angular/core';
import * as LocalForage from 'localforage';
import 'localforage';
import IdleQueue from 'custom-idle-queue';
import { PoLokiDriver } from '../drivers/lokijs/po-loki-driver';
export const PO_STORAGE_CONFIG_TOKEN = new InjectionToken('PO_STORAGE_CONFIG_TOKEN');
/**
 * @description
 *
 * O PO Storage é uma biblioteca que fornece um serviço para armazenamento de dados no dispositivo local, sendo semelhante
 * ao funcionamento do [IonicStorage](https://ionicframework.com/docs/storage/).
 * É possível utilizar os drivers [Websql](https://dev.w3.org/html5/webdatabase/), [Indexeddb](https://www.w3.org/TR/IndexedDB/),
 * [LocalStorage](https://html.spec.whatwg.org/multipage/webstorage.html) e também [LokiJS](https://github.com/techfort/LokiJS/wiki).
 *
 * Para um melhor ganho de performance ao buscar e salvar dados, recomendamos a utilização do `LokiJS`, um *database*
 * orientado a documento semelhante ao MongoDB, que além de permitir a persistência dos dados no dispositivo possibilita
 * também o armazenamento dos dados em memória. Outra vantagem, é o aumento do limite de armazenamento para
 * aproximadamente `300mb`.
 *
 * A estrutura utilizada para armazenar os dados é a de chave/valor, onde uma chave funciona como um identificador exclusivo.
 *
 * #### Instalando o PO Storage
 *
 * Para instalar o `po-storage` em sua aplicação execute o seguinte comando:
 *
 * ```shell
 * ng add @po-ui/ng-storage
 * ```
 * Será instalado o pacote `@po-ui/ng-storage` e também já importará `PoStorageModule` no módulo principal da sua aplicação, conforme abaixo:
 *
 * ```typescript
 * import { PoStorageModule } from '@po-ui/ng-storage';
 *
 * @NgModule({
 *  declarations: [...],
 *  imports: [
 *    // Importação do módulo PoStorageModule
 *    PoStorageModule.forRoot(),
 *  ],
 *  bootstrap: [IonicApp],
 *  providers: [...]
 * })
 * export class AppModule {}
 * ```
 *
 * Com a declaração do módulo, é criada uma base de dados no armazenamento local e o serviço `PoStorageService` estará
 * pronto para ser utilizada na sua aplicação.
 *
 * #### Configurando as opções de armazenamento
 *
 * Na importação do módulo, o método `PoStorageModule.forRoot()` pode receber como parâmetro um objeto do tipo
 * [`PoStorageConfig`](documentation/po-storage#po-storage-config),
 * que serve para configurar as opções personalizadas do armazenamento, como por exemplo: o tipo de armazenamento
 * preferêncial.
 *
 * Caso não seja passada nenhuma configuração a ordem padrão será: ['websql', 'indexeddb', 'localstorage', 'lokijs'].
 *
 * Abaixo segue um exemplo de configuração onde o storage preferencial passa a ser o `lokijs`:
 *
 * ```typescript
 * import { PoStorageModule } from '@po-ui/ng-storage';
 *
 * @NgModule({
 *  declarations: [...],
 *  imports: [
 *    // Importação do módulo PoStorageModule com a configuração personalizada
 *    PoStorageModule.forRoot({
 *      name: 'mystorage',
 *      storeName: '_mystore',
 *      driverOrder: ['lokijs', 'websql', 'indexeddb', 'localstorage']
 *    }),
 *  ],
 *  bootstrap: [IonicApp],
 *  providers: [...]
 * })
 * export class AppModule {}
 * ```
 */
export class PoStorageService {
    constructor(config) {
        this.driver = null;
        this.idleQueue = new IdleQueue();
        this.lokijsDriver = new PoLokiDriver();
        this.setStoragePromise(config);
    }
    /**
     * Retorna a configuração padrão para o armazenamento. Caso nenhuma configuração seja inserida,
     * essa configuração será utilizada.
     *
     * @returns {PoStorageConfig} Objeto com a configuração padrão do armazenamento.
     */
    static getDefaultConfig() {
        return {
            name: '_postorage',
            storeName: '_pokv',
            driverOrder: ['websql', 'indexeddb', 'localstorage', 'lokijs']
        };
    }
    /**
     * Cria uma instância do `PoStorageService` com a configuração de armazenamento passada como parâmetro.
     *
     * @param {PoStorageConfig} storageConfig Configuração para o armazenamento.
     * @returns {PoStorageService} Instância do `PoStorageService`.
     */
    static providePoStorage(storageConfig) {
        return new PoStorageService(PoStorageService.getConfig(storageConfig));
    }
    static getConfig(storageConfig) {
        return storageConfig || PoStorageService.getDefaultConfig();
    }
    /**
     * Busca uma lista armazenada pela chave e concatena com a lista passada por parâmetro.
     *
     * Por exemplo:
     *
     * ``` typescript
     * const clients = [ { name: 'Marie', age: 23 }, { name: 'Pether', age: 39 }];
     *
     * this.poStorageService.set('clientKey', clients).then(() => {});
     *
     * ...
     *
     * const newClients = [ { name: 'Lisa', age: 36 }, { name: 'Bruce', age: 18 } ];
     *
     * this.poStorageService.appendArrayToArray('clientKey', newClients).then(() => {
     *   // A lista agora será:
     *   // [ { name: 'Marie', age: 23 }, { name: 'Pether', age: 39 }, { name: 'Lisa', age: 36 }, { name: 'Bruce', age: 18 }];
     * });
     * ```
     *
     * @param {string} key Chave da lista armazenada.
     * @param {Array} value Lista que será concatenada.
     *
     * @returns {Promise<any>} Promessa que é resolvida após as duas listas serem concatenadas e armazenadas localmente.
     */
    appendArrayToArray(key, value) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.getArrayOfStorage(key);
            const newData = [...data, ...value];
            return this.set(key, newData);
        });
    }
    /**
     * Acrescenta um item em uma lista armazenada pela chave.
     *
     * @param {string} key Chave da lista armazenada.
     * @param {Array} value Item que será acrescentado na lista.
     *
     * @returns {Promise<any>} Promessa que é resolvida após o item ser acrescentado na lista armazenada.
     */
    appendItemToArray(key, value) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.getArrayOfStorage(key);
            data.push(value);
            return this.set(key, data);
        });
    }
    /**
     * Remove todos os itens da base de dados local configurada na declaração do módulo `PoStorageModule`.
     *
     * > Utilize este método com cautela, para evitar a perda indesejada de dados.
     *
     * @returns {Promise<void>} Promessa que é resolvida após todos os itens da base de dados local serem removidos.
     */
    clear() {
        return this.storagePromise.then(store => store.clear());
    }
    /**
     * Verifica se existe um valor dentro de uma determinada chave.
     *
     * @param {string} key Chave que será verificada.
     *
     * @returns {Promise<boolean>} Promessa que é resolvida quando a verificação da existência do valor na chave é concluída.
     */
    exists(key) {
        return this.get(key).then(data => Promise.resolve(data !== null));
    }
    /**
     * Itera sobre todas as chaves armazenadas.
     *
     * @param {any} iteratorCallback Função de `callback` que é chamada a cada iteração, com os seguintes parâmetros:
     * valor, chave e número da iteração.
     *
     * Exemplo de utilização:
     *
     * ``` typescript
     * this.poStorageService.forEach((value: any, key: string, iterationNumber: number) => {
     *   // Iteração sobre cada chave armazenada.
     * });
     * ```
     *
     * @returns {Promise<void>} Promessa que é resolvida após a iteração sobre todas as chaves armazenadas.
     */
    forEach(iteratorCallback) {
        return this.storagePromise.then(store => store.iterate(iteratorCallback));
    }
    /**
     * Retorna o valor armazenado em uma determinada chave.
     *
     * @param {string} key Chave que identifica o item.
     * @param {boolean} lock Define se irá travar a leitura e a escrita da base de dados para não ser acessada de forma paralela.
     * Caso outra leitura/escrita já tenha sido iniciada, este método irá esperar o outro terminar para então começar.
     *
     * Padrão: `false`.
     *
     * > Esta definição só será válida se o outro acesso paralelo a este método também estiver com o parâmetro *lock* ativado.
     * @returns {Promise<any>} Promessa que é resolvida após o item ser buscado.
     */
    get(key, lock = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (lock) {
                yield this.requestIdlePromise();
                return yield this.idleQueue.wrapCall(() => __awaiter(this, void 0, void 0, function* () {
                    yield this.getImmutableItem(key);
                }));
            }
            return yield this.getImmutableItem(key);
        });
    }
    /**
     * Retorna o nome do *driver* que está sendo usado para armazenar os dados, por exemplo: localStorage.
     *
     * @returns {string | null} Nome do *driver*.
     */
    getDriver() {
        return this.driver;
    }
    /**
     * Retorna o primeiro item de uma lista para uma determinada chave.
     *
     * @param {string} key Chave da lista.
     * @returns {Promise<any>} Promessa que é resolvida após o primeiro item ser encontrado.
     */
    getFirstItem(key) {
        return this.get(key).then((data) => Promise.resolve(data ? data[0] : null));
    }
    /**
     * Remove o primeiro item de uma lista a partir da chave.
     *
     * @param {string} key Chave da lista que será removido o primeiro item.
     * @returns {Promise<any>} Promessa que é resolvida após o primeiro item da lista ser removido.
     */
    getItemAndRemove(key) {
        return this.get(key).then((data) => {
            if (data === null) {
                return null;
            }
            const item = data.shift();
            return this.set(key, data).then(() => Promise.resolve(item));
        });
    }
    /**
     * Busca o primeiro objeto encontrado dentro de uma lista pelo do valor de um campo.
     *
     * Por exemplo:
     *
     * ``` typescript
     * const clients = [ { name: 'Marie', age: 23 }, { name: 'Pether', age: 39 }];
     *
     * this.poStorageService.set('clientKey', clients).then(() => {});
     *
     * ...
     *
     * this.poStorageService.getItemByField('clientKey', 'name', 'Marie').then(client => {
     *   // Resultado do console.log: { name: 'Marie', age: 23 }
     *   console.log(client);
     * });
     * ```
     *
     * @param {string} key Chave da lista.
     * @param {string} fieldName O campo a ser filtrado.
     * @param {any} fieldValue O valor do campo.
     * @returns {Promise<any>} Promessa que é resolvida com o item que foi encontrado.
     */
    getItemByField(key, fieldName, fieldValue) {
        return this.get(key).then((storageRecords) => {
            let storageRecordsFiltered = storageRecords.find(storageRecord => storageRecord[fieldName] === fieldValue);
            storageRecordsFiltered = storageRecordsFiltered || null;
            return Promise.resolve(storageRecordsFiltered);
        });
    }
    /**
     * Lista com todas as chaves armazenadas.
     *
     * @returns {Promise<Array<string>>} Promessa que é resolvida com todas as chaves armazenadas.
     */
    keys() {
        return this.storagePromise.then(store => store.keys());
    }
    /**
     * Quantidade de chaves armazenadas.
     *
     * @returns {Promise<number>} Promessa que é resolvida com o número de chaves armazenadas.
     */
    length() {
        return this.storagePromise.then(store => store.length());
    }
    /**
     * Utilizado para gerenciar o bloqueio e desbloqueio de recursos no `PoStorageService`.
     * Aguardando a liberação da utilização dos recursos que participam deste comportamento e posteriormente envolve o recurso
     * passado como parâmetro em um comportamento de bloqueio e desbloqueio.
     *
     * Este método se comporta igual a utilização em conjunta dos métodos: `PoStorageService.requestIdlePromise()`,
     * `PoStorageService.lock()` e `PoStorageService.unlook()`.
     *
     * Veja mais no método: [`PoStorage.requestIdlePromise()`](documentation/po-storage#request-idle-promise).
     *
     * @param {Function} limitedResource Função que será envolvida no comportamento de bloqueio e desbloqueio.
     */
    limitedCallWrap(limitedResource) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.requestIdlePromise();
            return this.idleQueue.wrapCall(limitedResource);
        });
    }
    /**
     * Incrementa um valor na fila de bloqueio do `PoStorageService`. Utilizado juntamente com o método `unlock` para poder
     * controlar a execução de uma determinada tarefa com o `PoStorage.requestIdlePromise()`.
     *
     * Veja mais no método: [`PoStorage.requestIdlePromise()`](documentation/po-storage#request-idle-promise).
     */
    lock() {
        this.idleQueue.lock();
    }
    /**
     * Determina se o processo de inicialização do *driver* assíncrono foi concluído.
     *
     * @returns {Promise<LocalForage>} Promessa que é resolvida quando o processo de inicialização do *driver* assíncrono
     * for concluído.
     */
    ready() {
        return this.storagePromise;
    }
    /**
     * Remove um valor associado a uma chave.
     *
     * @param {key} key Chave do valor que será removido.
     * @returns {Promise<any>} Promessa que é resolvida após o valor ser removido.
     */
    remove(key) {
        return this.storagePromise.then(store => store.removeItem(key));
    }
    /**
     * Remove uma propriedade de um objeto armazenado.
     *
     * @param {string} key Chave do objeto armazenado.
     * @param {string} property Propriedade que será removida.
     *
     * @returns {Promise<any>} Promessa que é resolvida após a propriedade ser removida.
     */
    removeIndexFromObject(key, property) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.getObjectOfStorage(key);
            delete data[property];
            return this.set(key, data);
        });
    }
    /**
     * Remove um objeto de uma lista armazenada pelo valor de uma propriedade.
     *
     * Por exemplo:
     *
     * ``` typescript
     * const clients = [ { name: 'Marie', age: 23 }, { name: 'Pether', age: 39 }];
     *
     * this.poStorageService.set('clientKey', clients).then(() => {});
     *
     * ...
     *
     * this.poStorageService.removeItemFromArray('clientKey', 'name', 'Marie').then(() => {
     *   // O objeto { name: 'Marie', age: 23 } foi removido da lista que está na chave 'clientKey'
     * });
     * ```
     *
     * @param {string} key Chave da lista que contém o item que será removido.
     * @param {string} field O campo a ser filtrado no item.
     * @param {string} value O valor do filtro.
     * @returns {Promise<any>} Promessa que é resolvida quando o objeto for removido da lista.
     */
    removeItemFromArray(key, field, value) {
        return __awaiter(this, void 0, void 0, function* () {
            let data = yield this.getArrayOfStorage(key);
            data = data.filter(item => item[field] !== value);
            return this.set(key, data);
        });
    }
    /**
     * <a id="request-idle-promise"></a>
     * Método que verifica se o acesso a base de dados configurada está liberado.
     *
     * Utilizado em conjunto com os métodos `lock()` e `unlock()` entre tarefas que não podem ser executadas de forma
     * paralela, para não causar inconsistências nos dados.
     *
     * Exemplo de utilização:
     *
     * ```
     * // Aguarda a liberação para continuar
     * await this.poStorage.requestIdlePromise();
     *
     * this.poStorage.lock();
     *
     * // Executa uma tarefa que irá ler e/ou escrever na base de dados configurada.
     *
     * this.poStorage.unlock();
     * ```
     *
     * > É importante sempre utilizá-lo antes de executar os métodos `lock()` e `unlock()` para garantir que a tarefa só
     * será executada caso o acesso esteja livre.
     *
     * @returns {Promise<any>} Promessa que é resolvida quando o acesso a base de dados configurada estiver liberado.
     */
    requestIdlePromise() {
        return this.idleQueue.requestIdlePromise();
    }
    /**
     * Grava um valor em uma determinada chave.
     *
     * @param {string} key Chave para o valor que será gravado.
     * @param {any} value Valor que será gravado.
     * @param {boolean} lock Define se irá travar a leitura e a escrita da base de dados para não ser acessada de forma paralela.
     * Caso outra leitura/escrita já tenha sido iniciada, este método irá esperar o outro terminar para então começar.
     *
     * Padrão: `false`.
     *
     * > Esta definição só será válida se o outro acesso paralelo a este método também estiver com o parâmetro *lock* ativado.
     * @returns {Promise<any>} Promessa que é resolvida após o valor ter sido gravado.
     */
    set(key, value, lock = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const store = yield this.storagePromise;
            const newValue = typeof value === 'object' ? JSON.parse(JSON.stringify(value)) : value;
            if (lock) {
                yield this.requestIdlePromise();
                return this.idleQueue.wrapCall(() => store.setItem(key, newValue));
            }
            return store.setItem(key, newValue);
        });
    }
    /**
     * Atribui um valor a uma propriedade de um objeto armazenado pela chave.
     *
     * Por exemplo:
     *
     * ``` typescript
     * const clients = [ { name: 'Marie', age: 23 }, { name: 'Pether', age: 39 }];
     *
     * this.poStorageService.set('clientKey', clients).then(() => {});
     *
     * ...
     *
     * this.poStorageService.setIndexToObject('clientKey', 'name', 'Clare').then(() => {
     *   // O objeto { name: 'Marie', age: 23 } passa a ser { name: 'Clare', age: 23 }
     * });
     * ```
     *
     * @param {string} key Chave do objeto.
     * @param {string} property Nome da propriedade do objeto.
     * @param {any} value Valor que será gravado na propriedade do objeto.
     */
    setIndexToObject(key, property, value) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.getObjectOfStorage(key);
            data[property] = value;
            return this.set(key, data);
        });
    }
    /**
     * Decrementa um valor na fila de bloqueio. Utilizado juntamente com o método `lock` para poder
     * controlar a execução de uma determinada tarefa com o `PoStorage.requestIdlePromise()`.
     *
     * Veja mais no método: [`PoStorage.requestIdlePromise()`](documentation/po-storage#request-idle-promise).
     */
    unlock() {
        this.idleQueue.unlock();
    }
    getArrayOfStorage(key) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.get(key);
            return data || [];
        });
    }
    getImmutableItem(key) {
        return __awaiter(this, void 0, void 0, function* () {
            const store = yield this.storagePromise;
            const items = yield store.getItem(key);
            return items ? JSON.parse(JSON.stringify(items)) : null;
        });
    }
    defineLocalForageDriver(localForageInstance, driverOrder) {
        return __awaiter(this, void 0, void 0, function* () {
            yield localForageInstance.defineDriver(this.lokijsDriver.getDriver());
            yield this.setDriver(localForageInstance, driverOrder);
            return localForageInstance;
        });
    }
    getDriverOrder(driverOrder) {
        return driverOrder.map(driver => {
            switch (driver) {
                case 'indexeddb':
                    return LocalForage.INDEXEDDB;
                case 'websql':
                    return LocalForage.WEBSQL;
                case 'localstorage':
                    return LocalForage.LOCALSTORAGE;
                default:
                    return driver;
            }
        });
    }
    getObjectOfStorage(key) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.get(key);
            return data || {};
        });
    }
    setDriver(localForageInstance, driverOrder) {
        return __awaiter(this, void 0, void 0, function* () {
            yield localForageInstance.setDriver(this.getDriverOrder(driverOrder));
            this.driver = localForageInstance.driver();
        });
    }
    setStoragePromise(config) {
        this.storagePromise = this.getStorageInstance(config);
    }
    getStorageInstance(config) {
        return __awaiter(this, void 0, void 0, function* () {
            const defaultConfig = PoStorageService.getDefaultConfig();
            const actualConfig = Object.assign(defaultConfig, config || {});
            const localForageInstance = LocalForage.createInstance(actualConfig);
            try {
                return yield this.defineLocalForageDriver(localForageInstance, actualConfig.driverOrder);
            }
            catch (_a) {
                throw new Error(`Cannot use this drivers: ${actualConfig.driverOrder.join(', ')}.`);
            }
        });
    }
}
PoStorageService.decorators = [
    { type: Injectable }
];
PoStorageService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [PO_STORAGE_CONFIG_TOKEN,] }] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tc3RvcmFnZS5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvc3RvcmFnZS9zcmMvbGliL3NlcnZpY2VzL3BvLXN0b3JhZ2Uuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsY0FBYyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRW5FLE9BQU8sS0FBSyxXQUFXLE1BQU0sYUFBYSxDQUFDO0FBQzNDLE9BQU8sYUFBYSxDQUFDO0FBRXJCLE9BQU8sU0FBUyxNQUFNLG1CQUFtQixDQUFDO0FBRTFDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQztBQUdoRSxNQUFNLENBQUMsTUFBTSx1QkFBdUIsR0FBRyxJQUFJLGNBQWMsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0FBRXJGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXVFRztBQUVILE1BQU0sT0FBTyxnQkFBZ0I7SUFNM0IsWUFBNkMsTUFBd0I7UUFMN0QsV0FBTSxHQUFXLElBQUksQ0FBQztRQUN0QixjQUFTLEdBQUcsSUFBSSxTQUFTLEVBQUUsQ0FBQztRQUtsQyxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7UUFDdkMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ2pDLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILE1BQU0sQ0FBQyxnQkFBZ0I7UUFDckIsT0FBTztZQUNMLElBQUksRUFBRSxZQUFZO1lBQ2xCLFNBQVMsRUFBRSxPQUFPO1lBQ2xCLFdBQVcsRUFBRSxDQUFDLFFBQVEsRUFBRSxXQUFXLEVBQUUsY0FBYyxFQUFFLFFBQVEsQ0FBQztTQUMvRCxDQUFDO0lBQ0osQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsTUFBTSxDQUFDLGdCQUFnQixDQUFDLGFBQStCO1FBQ3JELE9BQU8sSUFBSSxnQkFBZ0IsQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztJQUN6RSxDQUFDO0lBRU8sTUFBTSxDQUFDLFNBQVMsQ0FBQyxhQUErQjtRQUN0RCxPQUFPLGFBQWEsSUFBSSxnQkFBZ0IsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO0lBQzlELENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bd0JHO0lBQ0csa0JBQWtCLENBQUMsR0FBVyxFQUFFLEtBQWlCOztZQUNyRCxNQUFNLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUUvQyxNQUFNLE9BQU8sR0FBRyxDQUFDLEdBQUcsSUFBSSxFQUFFLEdBQUcsS0FBSyxDQUFDLENBQUM7WUFDcEMsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUNoQyxDQUFDO0tBQUE7SUFFRDs7Ozs7OztPQU9HO0lBQ0csaUJBQWlCLENBQUMsR0FBVyxFQUFFLEtBQVU7O1lBQzdDLE1BQU0sSUFBSSxHQUFHLE1BQU0sSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBRS9DLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDakIsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUM3QixDQUFDO0tBQUE7SUFFRDs7Ozs7O09BTUc7SUFDSCxLQUFLO1FBQ0gsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0lBQzFELENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxNQUFNLENBQUMsR0FBVztRQUNoQixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQztJQUNwRSxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7OztPQWVHO0lBQ0gsT0FBTyxDQUFDLGdCQUEyRTtRQUNqRixPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUM7SUFDNUUsQ0FBQztJQUVEOzs7Ozs7Ozs7OztPQVdHO0lBQ0csR0FBRyxDQUFDLEdBQVcsRUFBRSxPQUFnQixLQUFLOztZQUMxQyxJQUFJLElBQUksRUFBRTtnQkFDUixNQUFNLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO2dCQUNoQyxPQUFPLE1BQU0sSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsR0FBUyxFQUFFO29CQUM5QyxNQUFNLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDbkMsQ0FBQyxDQUFBLENBQUMsQ0FBQzthQUNKO1lBQ0QsT0FBTyxNQUFNLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUMxQyxDQUFDO0tBQUE7SUFFRDs7OztPQUlHO0lBQ0gsU0FBUztRQUNQLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUNyQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxZQUFZLENBQUMsR0FBVztRQUN0QixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBZ0IsRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUMxRixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxnQkFBZ0IsQ0FBQyxHQUFXO1FBQzFCLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFnQixFQUFFLEVBQUU7WUFDN0MsSUFBSSxJQUFJLEtBQUssSUFBSSxFQUFFO2dCQUNqQixPQUFPLElBQUksQ0FBQzthQUNiO1lBRUQsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQzFCLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUMvRCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXNCRztJQUNILGNBQWMsQ0FBQyxHQUFXLEVBQUUsU0FBaUIsRUFBRSxVQUFlO1FBQzVELE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxjQUEwQixFQUFFLEVBQUU7WUFDdkQsSUFBSSxzQkFBc0IsR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxLQUFLLFVBQVUsQ0FBQyxDQUFDO1lBQzNHLHNCQUFzQixHQUFHLHNCQUFzQixJQUFJLElBQUksQ0FBQztZQUV4RCxPQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsc0JBQXNCLENBQUMsQ0FBQztRQUNqRCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsSUFBSTtRQUNGLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE1BQU07UUFDSixPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7SUFDM0QsQ0FBQztJQUVEOzs7Ozs7Ozs7OztPQVdHO0lBQ0csZUFBZSxDQUFDLGVBQXlCOztZQUM3QyxNQUFNLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1lBQ2hDLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDbEQsQ0FBQztLQUFBO0lBRUQ7Ozs7O09BS0c7SUFDSCxJQUFJO1FBQ0YsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUN4QixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxLQUFLO1FBQ0gsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDO0lBQzdCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILE1BQU0sQ0FBQyxHQUFXO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDbEUsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDRyxxQkFBcUIsQ0FBQyxHQUFXLEVBQUUsUUFBZ0I7O1lBQ3ZELE1BQU0sSUFBSSxHQUFHLE1BQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBRWhELE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3RCLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDN0IsQ0FBQztLQUFBO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXFCRztJQUNHLG1CQUFtQixDQUFDLEdBQVcsRUFBRSxLQUFhLEVBQUUsS0FBVTs7WUFDOUQsSUFBSSxJQUFJLEdBQUcsTUFBTSxJQUFJLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLENBQUM7WUFFN0MsSUFBSSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssS0FBSyxDQUFDLENBQUM7WUFDbEQsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUM3QixDQUFDO0tBQUE7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bd0JHO0lBQ0gsa0JBQWtCO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO0lBQzdDLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7O09BWUc7SUFDRyxHQUFHLENBQUMsR0FBVyxFQUFFLEtBQVUsRUFBRSxPQUFnQixLQUFLOztZQUN0RCxNQUFNLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUM7WUFDeEMsTUFBTSxRQUFRLEdBQUcsT0FBTyxLQUFLLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO1lBRXZGLElBQUksSUFBSSxFQUFFO2dCQUNSLE1BQU0sSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7Z0JBQ2hDLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQzthQUNwRTtZQUVELE9BQU8sS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDdEMsQ0FBQztLQUFBO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bb0JHO0lBQ0csZ0JBQWdCLENBQUMsR0FBVyxFQUFFLFFBQWdCLEVBQUUsS0FBVTs7WUFDOUQsTUFBTSxJQUFJLEdBQUcsTUFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLENBQUM7WUFFaEQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEtBQUssQ0FBQztZQUN2QixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzdCLENBQUM7S0FBQTtJQUVEOzs7OztPQUtHO0lBQ0gsTUFBTTtRQUNKLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDMUIsQ0FBQztJQUVhLGlCQUFpQixDQUFDLEdBQVc7O1lBQ3pDLE1BQU0sSUFBSSxHQUFHLE1BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNqQyxPQUFPLElBQUksSUFBSSxFQUFFLENBQUM7UUFDcEIsQ0FBQztLQUFBO0lBRWEsZ0JBQWdCLENBQUMsR0FBVzs7WUFDeEMsTUFBTSxLQUFLLEdBQUcsTUFBTSxJQUFJLENBQUMsY0FBYyxDQUFDO1lBQ3hDLE1BQU0sS0FBSyxHQUFHLE1BQU0sS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUN2QyxPQUFPLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztRQUMxRCxDQUFDO0tBQUE7SUFFYSx1QkFBdUIsQ0FBQyxtQkFBd0IsRUFBRSxXQUFXOztZQUN6RSxNQUFNLG1CQUFtQixDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUM7WUFDdEUsTUFBTSxJQUFJLENBQUMsU0FBUyxDQUFDLG1CQUFtQixFQUFFLFdBQVcsQ0FBQyxDQUFDO1lBQ3ZELE9BQU8sbUJBQW1CLENBQUM7UUFDN0IsQ0FBQztLQUFBO0lBRU8sY0FBYyxDQUFDLFdBQTBCO1FBQy9DLE9BQU8sV0FBVyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUM5QixRQUFRLE1BQU0sRUFBRTtnQkFDZCxLQUFLLFdBQVc7b0JBQ2QsT0FBTyxXQUFXLENBQUMsU0FBUyxDQUFDO2dCQUMvQixLQUFLLFFBQVE7b0JBQ1gsT0FBTyxXQUFXLENBQUMsTUFBTSxDQUFDO2dCQUM1QixLQUFLLGNBQWM7b0JBQ2pCLE9BQU8sV0FBVyxDQUFDLFlBQVksQ0FBQztnQkFDbEM7b0JBQ0UsT0FBTyxNQUFNLENBQUM7YUFDakI7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFYSxrQkFBa0IsQ0FBQyxHQUFXOztZQUMxQyxNQUFNLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDakMsT0FBTyxJQUFJLElBQUksRUFBRSxDQUFDO1FBQ3BCLENBQUM7S0FBQTtJQUVhLFNBQVMsQ0FBQyxtQkFBZ0MsRUFBRSxXQUFXOztZQUNuRSxNQUFNLG1CQUFtQixDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7WUFDdEUsSUFBSSxDQUFDLE1BQU0sR0FBRyxtQkFBbUIsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUM3QyxDQUFDO0tBQUE7SUFFTyxpQkFBaUIsQ0FBQyxNQUF1QjtRQUMvQyxJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBRWEsa0JBQWtCLENBQUMsTUFBdUI7O1lBQ3RELE1BQU0sYUFBYSxHQUFHLGdCQUFnQixDQUFDLGdCQUFnQixFQUFFLENBQUM7WUFDMUQsTUFBTSxZQUFZLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxhQUFhLEVBQUUsTUFBTSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1lBRWhFLE1BQU0sbUJBQW1CLEdBQUcsV0FBVyxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUVyRSxJQUFJO2dCQUNGLE9BQU8sTUFBTSxJQUFJLENBQUMsdUJBQXVCLENBQUMsbUJBQW1CLEVBQUUsWUFBWSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2FBQzFGO1lBQUMsV0FBTTtnQkFDTixNQUFNLElBQUksS0FBSyxDQUFDLDRCQUE0QixZQUFZLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDckY7UUFDSCxDQUFDO0tBQUE7OztZQTdkRixVQUFVOzs7NENBT0ksTUFBTSxTQUFDLHVCQUF1QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSwgSW5qZWN0aW9uVG9rZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbmltcG9ydCAqIGFzIExvY2FsRm9yYWdlIGZyb20gJ2xvY2FsZm9yYWdlJztcclxuaW1wb3J0ICdsb2NhbGZvcmFnZSc7XHJcblxyXG5pbXBvcnQgSWRsZVF1ZXVlIGZyb20gJ2N1c3RvbS1pZGxlLXF1ZXVlJztcclxuXHJcbmltcG9ydCB7IFBvTG9raURyaXZlciB9IGZyb20gJy4uL2RyaXZlcnMvbG9raWpzL3BvLWxva2ktZHJpdmVyJztcclxuaW1wb3J0IHsgUG9TdG9yYWdlQ29uZmlnIH0gZnJvbSAnLi9wby1zdG9yYWdlLWNvbmZpZy5pbnRlcmZhY2UnO1xyXG5cclxuZXhwb3J0IGNvbnN0IFBPX1NUT1JBR0VfQ09ORklHX1RPS0VOID0gbmV3IEluamVjdGlvblRva2VuKCdQT19TVE9SQUdFX0NPTkZJR19UT0tFTicpO1xyXG5cclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBPIFBPIFN0b3JhZ2Ugw6kgdW1hIGJpYmxpb3RlY2EgcXVlIGZvcm5lY2UgdW0gc2VydmnDp28gcGFyYSBhcm1hemVuYW1lbnRvIGRlIGRhZG9zIG5vIGRpc3Bvc2l0aXZvIGxvY2FsLCBzZW5kbyBzZW1lbGhhbnRlXHJcbiAqIGFvIGZ1bmNpb25hbWVudG8gZG8gW0lvbmljU3RvcmFnZV0oaHR0cHM6Ly9pb25pY2ZyYW1ld29yay5jb20vZG9jcy9zdG9yYWdlLykuXHJcbiAqIMOJIHBvc3PDrXZlbCB1dGlsaXphciBvcyBkcml2ZXJzIFtXZWJzcWxdKGh0dHBzOi8vZGV2LnczLm9yZy9odG1sNS93ZWJkYXRhYmFzZS8pLCBbSW5kZXhlZGRiXShodHRwczovL3d3dy53My5vcmcvVFIvSW5kZXhlZERCLyksXHJcbiAqIFtMb2NhbFN0b3JhZ2VdKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3dlYnN0b3JhZ2UuaHRtbCkgZSB0YW1iw6ltIFtMb2tpSlNdKGh0dHBzOi8vZ2l0aHViLmNvbS90ZWNoZm9ydC9Mb2tpSlMvd2lraSkuXHJcbiAqXHJcbiAqIFBhcmEgdW0gbWVsaG9yIGdhbmhvIGRlIHBlcmZvcm1hbmNlIGFvIGJ1c2NhciBlIHNhbHZhciBkYWRvcywgcmVjb21lbmRhbW9zIGEgdXRpbGl6YcOnw6NvIGRvIGBMb2tpSlNgLCB1bSAqZGF0YWJhc2UqXHJcbiAqIG9yaWVudGFkbyBhIGRvY3VtZW50byBzZW1lbGhhbnRlIGFvIE1vbmdvREIsIHF1ZSBhbMOpbSBkZSBwZXJtaXRpciBhIHBlcnNpc3TDqm5jaWEgZG9zIGRhZG9zIG5vIGRpc3Bvc2l0aXZvIHBvc3NpYmlsaXRhXHJcbiAqIHRhbWLDqW0gbyBhcm1hemVuYW1lbnRvIGRvcyBkYWRvcyBlbSBtZW3Ds3JpYS4gT3V0cmEgdmFudGFnZW0sIMOpIG8gYXVtZW50byBkbyBsaW1pdGUgZGUgYXJtYXplbmFtZW50byBwYXJhXHJcbiAqIGFwcm94aW1hZGFtZW50ZSBgMzAwbWJgLlxyXG4gKlxyXG4gKiBBIGVzdHJ1dHVyYSB1dGlsaXphZGEgcGFyYSBhcm1hemVuYXIgb3MgZGFkb3Mgw6kgYSBkZSBjaGF2ZS92YWxvciwgb25kZSB1bWEgY2hhdmUgZnVuY2lvbmEgY29tbyB1bSBpZGVudGlmaWNhZG9yIGV4Y2x1c2l2by5cclxuICpcclxuICogIyMjIyBJbnN0YWxhbmRvIG8gUE8gU3RvcmFnZVxyXG4gKlxyXG4gKiBQYXJhIGluc3RhbGFyIG8gYHBvLXN0b3JhZ2VgIGVtIHN1YSBhcGxpY2HDp8OjbyBleGVjdXRlIG8gc2VndWludGUgY29tYW5kbzpcclxuICpcclxuICogYGBgc2hlbGxcclxuICogbmcgYWRkIEBwby11aS9uZy1zdG9yYWdlXHJcbiAqIGBgYFxyXG4gKiBTZXLDoSBpbnN0YWxhZG8gbyBwYWNvdGUgYEBwby11aS9uZy1zdG9yYWdlYCBlIHRhbWLDqW0gasOhIGltcG9ydGFyw6EgYFBvU3RvcmFnZU1vZHVsZWAgbm8gbcOzZHVsbyBwcmluY2lwYWwgZGEgc3VhIGFwbGljYcOnw6NvLCBjb25mb3JtZSBhYmFpeG86XHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogaW1wb3J0IHsgUG9TdG9yYWdlTW9kdWxlIH0gZnJvbSAnQHBvLXVpL25nLXN0b3JhZ2UnO1xyXG4gKlxyXG4gKiBATmdNb2R1bGUoe1xyXG4gKiAgZGVjbGFyYXRpb25zOiBbLi4uXSxcclxuICogIGltcG9ydHM6IFtcclxuICogICAgLy8gSW1wb3J0YcOnw6NvIGRvIG3Ds2R1bG8gUG9TdG9yYWdlTW9kdWxlXHJcbiAqICAgIFBvU3RvcmFnZU1vZHVsZS5mb3JSb290KCksXHJcbiAqICBdLFxyXG4gKiAgYm9vdHN0cmFwOiBbSW9uaWNBcHBdLFxyXG4gKiAgcHJvdmlkZXJzOiBbLi4uXVxyXG4gKiB9KVxyXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHt9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBDb20gYSBkZWNsYXJhw6fDo28gZG8gbcOzZHVsbywgw6kgY3JpYWRhIHVtYSBiYXNlIGRlIGRhZG9zIG5vIGFybWF6ZW5hbWVudG8gbG9jYWwgZSBvIHNlcnZpw6dvIGBQb1N0b3JhZ2VTZXJ2aWNlYCBlc3RhcsOhXHJcbiAqIHByb250byBwYXJhIHNlciB1dGlsaXphZGEgbmEgc3VhIGFwbGljYcOnw6NvLlxyXG4gKlxyXG4gKiAjIyMjIENvbmZpZ3VyYW5kbyBhcyBvcMOnw7VlcyBkZSBhcm1hemVuYW1lbnRvXHJcbiAqXHJcbiAqIE5hIGltcG9ydGHDp8OjbyBkbyBtw7NkdWxvLCBvIG3DqXRvZG8gYFBvU3RvcmFnZU1vZHVsZS5mb3JSb290KClgIHBvZGUgcmVjZWJlciBjb21vIHBhcsOibWV0cm8gdW0gb2JqZXRvIGRvIHRpcG9cclxuICogW2BQb1N0b3JhZ2VDb25maWdgXShkb2N1bWVudGF0aW9uL3BvLXN0b3JhZ2UjcG8tc3RvcmFnZS1jb25maWcpLFxyXG4gKiBxdWUgc2VydmUgcGFyYSBjb25maWd1cmFyIGFzIG9ww6fDtWVzIHBlcnNvbmFsaXphZGFzIGRvIGFybWF6ZW5hbWVudG8sIGNvbW8gcG9yIGV4ZW1wbG86IG8gdGlwbyBkZSBhcm1hemVuYW1lbnRvXHJcbiAqIHByZWZlcsOqbmNpYWwuXHJcbiAqXHJcbiAqIENhc28gbsOjbyBzZWphIHBhc3NhZGEgbmVuaHVtYSBjb25maWd1cmHDp8OjbyBhIG9yZGVtIHBhZHLDo28gc2Vyw6E6IFsnd2Vic3FsJywgJ2luZGV4ZWRkYicsICdsb2NhbHN0b3JhZ2UnLCAnbG9raWpzJ10uXHJcbiAqXHJcbiAqIEFiYWl4byBzZWd1ZSB1bSBleGVtcGxvIGRlIGNvbmZpZ3VyYcOnw6NvIG9uZGUgbyBzdG9yYWdlIHByZWZlcmVuY2lhbCBwYXNzYSBhIHNlciBvIGBsb2tpanNgOlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGltcG9ydCB7IFBvU3RvcmFnZU1vZHVsZSB9IGZyb20gJ0Bwby11aS9uZy1zdG9yYWdlJztcclxuICpcclxuICogQE5nTW9kdWxlKHtcclxuICogIGRlY2xhcmF0aW9uczogWy4uLl0sXHJcbiAqICBpbXBvcnRzOiBbXHJcbiAqICAgIC8vIEltcG9ydGHDp8OjbyBkbyBtw7NkdWxvIFBvU3RvcmFnZU1vZHVsZSBjb20gYSBjb25maWd1cmHDp8OjbyBwZXJzb25hbGl6YWRhXHJcbiAqICAgIFBvU3RvcmFnZU1vZHVsZS5mb3JSb290KHtcclxuICogICAgICBuYW1lOiAnbXlzdG9yYWdlJyxcclxuICogICAgICBzdG9yZU5hbWU6ICdfbXlzdG9yZScsXHJcbiAqICAgICAgZHJpdmVyT3JkZXI6IFsnbG9raWpzJywgJ3dlYnNxbCcsICdpbmRleGVkZGInLCAnbG9jYWxzdG9yYWdlJ11cclxuICogICAgfSksXHJcbiAqICBdLFxyXG4gKiAgYm9vdHN0cmFwOiBbSW9uaWNBcHBdLFxyXG4gKiAgcHJvdmlkZXJzOiBbLi4uXVxyXG4gKiB9KVxyXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHt9XHJcbiAqIGBgYFxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgUG9TdG9yYWdlU2VydmljZSB7XHJcbiAgcHJpdmF0ZSBkcml2ZXI6IHN0cmluZyA9IG51bGw7XHJcbiAgcHJpdmF0ZSBpZGxlUXVldWUgPSBuZXcgSWRsZVF1ZXVlKCk7XHJcbiAgcHJpdmF0ZSBzdG9yYWdlUHJvbWlzZTogUHJvbWlzZTxMb2NhbEZvcmFnZT47XHJcbiAgcHJpdmF0ZSBsb2tpanNEcml2ZXI6IFBvTG9raURyaXZlcjtcclxuXHJcbiAgY29uc3RydWN0b3IoQEluamVjdChQT19TVE9SQUdFX0NPTkZJR19UT0tFTikgY29uZmlnPzogUG9TdG9yYWdlQ29uZmlnKSB7XHJcbiAgICB0aGlzLmxva2lqc0RyaXZlciA9IG5ldyBQb0xva2lEcml2ZXIoKTtcclxuICAgIHRoaXMuc2V0U3RvcmFnZVByb21pc2UoY29uZmlnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldG9ybmEgYSBjb25maWd1cmHDp8OjbyBwYWRyw6NvIHBhcmEgbyBhcm1hemVuYW1lbnRvLiBDYXNvIG5lbmh1bWEgY29uZmlndXJhw6fDo28gc2VqYSBpbnNlcmlkYSxcclxuICAgKiBlc3NhIGNvbmZpZ3VyYcOnw6NvIHNlcsOhIHV0aWxpemFkYS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtQb1N0b3JhZ2VDb25maWd9IE9iamV0byBjb20gYSBjb25maWd1cmHDp8OjbyBwYWRyw6NvIGRvIGFybWF6ZW5hbWVudG8uXHJcbiAgICovXHJcbiAgc3RhdGljIGdldERlZmF1bHRDb25maWcoKTogUG9TdG9yYWdlQ29uZmlnIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG5hbWU6ICdfcG9zdG9yYWdlJyxcclxuICAgICAgc3RvcmVOYW1lOiAnX3Bva3YnLFxyXG4gICAgICBkcml2ZXJPcmRlcjogWyd3ZWJzcWwnLCAnaW5kZXhlZGRiJywgJ2xvY2Fsc3RvcmFnZScsICdsb2tpanMnXVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyaWEgdW1hIGluc3TDom5jaWEgZG8gYFBvU3RvcmFnZVNlcnZpY2VgIGNvbSBhIGNvbmZpZ3VyYcOnw6NvIGRlIGFybWF6ZW5hbWVudG8gcGFzc2FkYSBjb21vIHBhcsOibWV0cm8uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1BvU3RvcmFnZUNvbmZpZ30gc3RvcmFnZUNvbmZpZyBDb25maWd1cmHDp8OjbyBwYXJhIG8gYXJtYXplbmFtZW50by5cclxuICAgKiBAcmV0dXJucyB7UG9TdG9yYWdlU2VydmljZX0gSW5zdMOibmNpYSBkbyBgUG9TdG9yYWdlU2VydmljZWAuXHJcbiAgICovXHJcbiAgc3RhdGljIHByb3ZpZGVQb1N0b3JhZ2Uoc3RvcmFnZUNvbmZpZz86IFBvU3RvcmFnZUNvbmZpZyk6IFBvU3RvcmFnZVNlcnZpY2Uge1xyXG4gICAgcmV0dXJuIG5ldyBQb1N0b3JhZ2VTZXJ2aWNlKFBvU3RvcmFnZVNlcnZpY2UuZ2V0Q29uZmlnKHN0b3JhZ2VDb25maWcpKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RhdGljIGdldENvbmZpZyhzdG9yYWdlQ29uZmlnPzogUG9TdG9yYWdlQ29uZmlnKSB7XHJcbiAgICByZXR1cm4gc3RvcmFnZUNvbmZpZyB8fCBQb1N0b3JhZ2VTZXJ2aWNlLmdldERlZmF1bHRDb25maWcoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJ1c2NhIHVtYSBsaXN0YSBhcm1hemVuYWRhIHBlbGEgY2hhdmUgZSBjb25jYXRlbmEgY29tIGEgbGlzdGEgcGFzc2FkYSBwb3IgcGFyw6JtZXRyby5cclxuICAgKlxyXG4gICAqIFBvciBleGVtcGxvOlxyXG4gICAqXHJcbiAgICogYGBgIHR5cGVzY3JpcHRcclxuICAgKiBjb25zdCBjbGllbnRzID0gWyB7IG5hbWU6ICdNYXJpZScsIGFnZTogMjMgfSwgeyBuYW1lOiAnUGV0aGVyJywgYWdlOiAzOSB9XTtcclxuICAgKlxyXG4gICAqIHRoaXMucG9TdG9yYWdlU2VydmljZS5zZXQoJ2NsaWVudEtleScsIGNsaWVudHMpLnRoZW4oKCkgPT4ge30pO1xyXG4gICAqXHJcbiAgICogLi4uXHJcbiAgICpcclxuICAgKiBjb25zdCBuZXdDbGllbnRzID0gWyB7IG5hbWU6ICdMaXNhJywgYWdlOiAzNiB9LCB7IG5hbWU6ICdCcnVjZScsIGFnZTogMTggfSBdO1xyXG4gICAqXHJcbiAgICogdGhpcy5wb1N0b3JhZ2VTZXJ2aWNlLmFwcGVuZEFycmF5VG9BcnJheSgnY2xpZW50S2V5JywgbmV3Q2xpZW50cykudGhlbigoKSA9PiB7XHJcbiAgICogICAvLyBBIGxpc3RhIGFnb3JhIHNlcsOhOlxyXG4gICAqICAgLy8gWyB7IG5hbWU6ICdNYXJpZScsIGFnZTogMjMgfSwgeyBuYW1lOiAnUGV0aGVyJywgYWdlOiAzOSB9LCB7IG5hbWU6ICdMaXNhJywgYWdlOiAzNiB9LCB7IG5hbWU6ICdCcnVjZScsIGFnZTogMTggfV07XHJcbiAgICogfSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IENoYXZlIGRhIGxpc3RhIGFybWF6ZW5hZGEuXHJcbiAgICogQHBhcmFtIHtBcnJheX0gdmFsdWUgTGlzdGEgcXVlIHNlcsOhIGNvbmNhdGVuYWRhLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gUHJvbWVzc2EgcXVlIMOpIHJlc29sdmlkYSBhcMOzcyBhcyBkdWFzIGxpc3RhcyBzZXJlbSBjb25jYXRlbmFkYXMgZSBhcm1hemVuYWRhcyBsb2NhbG1lbnRlLlxyXG4gICAqL1xyXG4gIGFzeW5jIGFwcGVuZEFycmF5VG9BcnJheShrZXk6IHN0cmluZywgdmFsdWU6IEFycmF5PGFueT4pOiBQcm9taXNlPGFueT4ge1xyXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZ2V0QXJyYXlPZlN0b3JhZ2Uoa2V5KTtcclxuXHJcbiAgICBjb25zdCBuZXdEYXRhID0gWy4uLmRhdGEsIC4uLnZhbHVlXTtcclxuICAgIHJldHVybiB0aGlzLnNldChrZXksIG5ld0RhdGEpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWNyZXNjZW50YSB1bSBpdGVtIGVtIHVtYSBsaXN0YSBhcm1hemVuYWRhIHBlbGEgY2hhdmUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IENoYXZlIGRhIGxpc3RhIGFybWF6ZW5hZGEuXHJcbiAgICogQHBhcmFtIHtBcnJheX0gdmFsdWUgSXRlbSBxdWUgc2Vyw6EgYWNyZXNjZW50YWRvIG5hIGxpc3RhLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gUHJvbWVzc2EgcXVlIMOpIHJlc29sdmlkYSBhcMOzcyBvIGl0ZW0gc2VyIGFjcmVzY2VudGFkbyBuYSBsaXN0YSBhcm1hemVuYWRhLlxyXG4gICAqL1xyXG4gIGFzeW5jIGFwcGVuZEl0ZW1Ub0FycmF5KGtleTogc3RyaW5nLCB2YWx1ZTogYW55KTogUHJvbWlzZTxhbnk+IHtcclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmdldEFycmF5T2ZTdG9yYWdlKGtleSk7XHJcblxyXG4gICAgZGF0YS5wdXNoKHZhbHVlKTtcclxuICAgIHJldHVybiB0aGlzLnNldChrZXksIGRhdGEpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIHRvZG9zIG9zIGl0ZW5zIGRhIGJhc2UgZGUgZGFkb3MgbG9jYWwgY29uZmlndXJhZGEgbmEgZGVjbGFyYcOnw6NvIGRvIG3Ds2R1bG8gYFBvU3RvcmFnZU1vZHVsZWAuXHJcbiAgICpcclxuICAgKiA+IFV0aWxpemUgZXN0ZSBtw6l0b2RvIGNvbSBjYXV0ZWxhLCBwYXJhIGV2aXRhciBhIHBlcmRhIGluZGVzZWphZGEgZGUgZGFkb3MuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gUHJvbWVzc2EgcXVlIMOpIHJlc29sdmlkYSBhcMOzcyB0b2RvcyBvcyBpdGVucyBkYSBiYXNlIGRlIGRhZG9zIGxvY2FsIHNlcmVtIHJlbW92aWRvcy5cclxuICAgKi9cclxuICBjbGVhcigpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VQcm9taXNlLnRoZW4oc3RvcmUgPT4gc3RvcmUuY2xlYXIoKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBWZXJpZmljYSBzZSBleGlzdGUgdW0gdmFsb3IgZGVudHJvIGRlIHVtYSBkZXRlcm1pbmFkYSBjaGF2ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgQ2hhdmUgcXVlIHNlcsOhIHZlcmlmaWNhZGEuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gUHJvbWVzc2EgcXVlIMOpIHJlc29sdmlkYSBxdWFuZG8gYSB2ZXJpZmljYcOnw6NvIGRhIGV4aXN0w6puY2lhIGRvIHZhbG9yIG5hIGNoYXZlIMOpIGNvbmNsdcOtZGEuXHJcbiAgICovXHJcbiAgZXhpc3RzKGtleTogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXQoa2V5KS50aGVuKGRhdGEgPT4gUHJvbWlzZS5yZXNvbHZlKGRhdGEgIT09IG51bGwpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEl0ZXJhIHNvYnJlIHRvZGFzIGFzIGNoYXZlcyBhcm1hemVuYWRhcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YW55fSBpdGVyYXRvckNhbGxiYWNrIEZ1bsOnw6NvIGRlIGBjYWxsYmFja2AgcXVlIMOpIGNoYW1hZGEgYSBjYWRhIGl0ZXJhw6fDo28sIGNvbSBvcyBzZWd1aW50ZXMgcGFyw6JtZXRyb3M6XHJcbiAgICogdmFsb3IsIGNoYXZlIGUgbsO6bWVybyBkYSBpdGVyYcOnw6NvLlxyXG4gICAqXHJcbiAgICogRXhlbXBsbyBkZSB1dGlsaXphw6fDo286XHJcbiAgICpcclxuICAgKiBgYGAgdHlwZXNjcmlwdFxyXG4gICAqIHRoaXMucG9TdG9yYWdlU2VydmljZS5mb3JFYWNoKCh2YWx1ZTogYW55LCBrZXk6IHN0cmluZywgaXRlcmF0aW9uTnVtYmVyOiBudW1iZXIpID0+IHtcclxuICAgKiAgIC8vIEl0ZXJhw6fDo28gc29icmUgY2FkYSBjaGF2ZSBhcm1hemVuYWRhLlxyXG4gICAqIH0pO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IFByb21lc3NhIHF1ZSDDqSByZXNvbHZpZGEgYXDDs3MgYSBpdGVyYcOnw6NvIHNvYnJlIHRvZGFzIGFzIGNoYXZlcyBhcm1hemVuYWRhcy5cclxuICAgKi9cclxuICBmb3JFYWNoKGl0ZXJhdG9yQ2FsbGJhY2s6ICh2YWx1ZTogYW55LCBrZXk6IHN0cmluZywgaXRlcmF0aW9uTnVtYmVyOiBudW1iZXIpID0+IGFueSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZVByb21pc2UudGhlbihzdG9yZSA9PiBzdG9yZS5pdGVyYXRlKGl0ZXJhdG9yQ2FsbGJhY2spKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldG9ybmEgbyB2YWxvciBhcm1hemVuYWRvIGVtIHVtYSBkZXRlcm1pbmFkYSBjaGF2ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgQ2hhdmUgcXVlIGlkZW50aWZpY2EgbyBpdGVtLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9jayBEZWZpbmUgc2UgaXLDoSB0cmF2YXIgYSBsZWl0dXJhIGUgYSBlc2NyaXRhIGRhIGJhc2UgZGUgZGFkb3MgcGFyYSBuw6NvIHNlciBhY2Vzc2FkYSBkZSBmb3JtYSBwYXJhbGVsYS5cclxuICAgKiBDYXNvIG91dHJhIGxlaXR1cmEvZXNjcml0YSBqw6EgdGVuaGEgc2lkbyBpbmljaWFkYSwgZXN0ZSBtw6l0b2RvIGlyw6EgZXNwZXJhciBvIG91dHJvIHRlcm1pbmFyIHBhcmEgZW50w6NvIGNvbWXDp2FyLlxyXG4gICAqXHJcbiAgICogUGFkcsOjbzogYGZhbHNlYC5cclxuICAgKlxyXG4gICAqID4gRXN0YSBkZWZpbmnDp8OjbyBzw7Mgc2Vyw6EgdsOhbGlkYSBzZSBvIG91dHJvIGFjZXNzbyBwYXJhbGVsbyBhIGVzdGUgbcOpdG9kbyB0YW1iw6ltIGVzdGl2ZXIgY29tIG8gcGFyw6JtZXRybyAqbG9jayogYXRpdmFkby5cclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBQcm9tZXNzYSBxdWUgw6kgcmVzb2x2aWRhIGFww7NzIG8gaXRlbSBzZXIgYnVzY2Fkby5cclxuICAgKi9cclxuICBhc3luYyBnZXQoa2V5OiBzdHJpbmcsIGxvY2s6IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8YW55PiB7XHJcbiAgICBpZiAobG9jaykge1xyXG4gICAgICBhd2FpdCB0aGlzLnJlcXVlc3RJZGxlUHJvbWlzZSgpO1xyXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5pZGxlUXVldWUud3JhcENhbGwoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuZ2V0SW1tdXRhYmxlSXRlbShrZXkpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldEltbXV0YWJsZUl0ZW0oa2V5KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldG9ybmEgbyBub21lIGRvICpkcml2ZXIqIHF1ZSBlc3TDoSBzZW5kbyB1c2FkbyBwYXJhIGFybWF6ZW5hciBvcyBkYWRvcywgcG9yIGV4ZW1wbG86IGxvY2FsU3RvcmFnZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCBudWxsfSBOb21lIGRvICpkcml2ZXIqLlxyXG4gICAqL1xyXG4gIGdldERyaXZlcigpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIHRoaXMuZHJpdmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0b3JuYSBvIHByaW1laXJvIGl0ZW0gZGUgdW1hIGxpc3RhIHBhcmEgdW1hIGRldGVybWluYWRhIGNoYXZlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBDaGF2ZSBkYSBsaXN0YS5cclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBQcm9tZXNzYSBxdWUgw6kgcmVzb2x2aWRhIGFww7NzIG8gcHJpbWVpcm8gaXRlbSBzZXIgZW5jb250cmFkby5cclxuICAgKi9cclxuICBnZXRGaXJzdEl0ZW0oa2V5OiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0KGtleSkudGhlbigoZGF0YTogQXJyYXk8YW55PikgPT4gUHJvbWlzZS5yZXNvbHZlKGRhdGEgPyBkYXRhWzBdIDogbnVsbCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIG8gcHJpbWVpcm8gaXRlbSBkZSB1bWEgbGlzdGEgYSBwYXJ0aXIgZGEgY2hhdmUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IENoYXZlIGRhIGxpc3RhIHF1ZSBzZXLDoSByZW1vdmlkbyBvIHByaW1laXJvIGl0ZW0uXHJcbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gUHJvbWVzc2EgcXVlIMOpIHJlc29sdmlkYSBhcMOzcyBvIHByaW1laXJvIGl0ZW0gZGEgbGlzdGEgc2VyIHJlbW92aWRvLlxyXG4gICAqL1xyXG4gIGdldEl0ZW1BbmRSZW1vdmUoa2V5OiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0KGtleSkudGhlbigoZGF0YTogQXJyYXk8YW55PikgPT4ge1xyXG4gICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBpdGVtID0gZGF0YS5zaGlmdCgpO1xyXG4gICAgICByZXR1cm4gdGhpcy5zZXQoa2V5LCBkYXRhKS50aGVuKCgpID0+IFByb21pc2UucmVzb2x2ZShpdGVtKSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJ1c2NhIG8gcHJpbWVpcm8gb2JqZXRvIGVuY29udHJhZG8gZGVudHJvIGRlIHVtYSBsaXN0YSBwZWxvIGRvIHZhbG9yIGRlIHVtIGNhbXBvLlxyXG4gICAqXHJcbiAgICogUG9yIGV4ZW1wbG86XHJcbiAgICpcclxuICAgKiBgYGAgdHlwZXNjcmlwdFxyXG4gICAqIGNvbnN0IGNsaWVudHMgPSBbIHsgbmFtZTogJ01hcmllJywgYWdlOiAyMyB9LCB7IG5hbWU6ICdQZXRoZXInLCBhZ2U6IDM5IH1dO1xyXG4gICAqXHJcbiAgICogdGhpcy5wb1N0b3JhZ2VTZXJ2aWNlLnNldCgnY2xpZW50S2V5JywgY2xpZW50cykudGhlbigoKSA9PiB7fSk7XHJcbiAgICpcclxuICAgKiAuLi5cclxuICAgKlxyXG4gICAqIHRoaXMucG9TdG9yYWdlU2VydmljZS5nZXRJdGVtQnlGaWVsZCgnY2xpZW50S2V5JywgJ25hbWUnLCAnTWFyaWUnKS50aGVuKGNsaWVudCA9PiB7XHJcbiAgICogICAvLyBSZXN1bHRhZG8gZG8gY29uc29sZS5sb2c6IHsgbmFtZTogJ01hcmllJywgYWdlOiAyMyB9XHJcbiAgICogICBjb25zb2xlLmxvZyhjbGllbnQpO1xyXG4gICAqIH0pO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBDaGF2ZSBkYSBsaXN0YS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGROYW1lIE8gY2FtcG8gYSBzZXIgZmlsdHJhZG8uXHJcbiAgICogQHBhcmFtIHthbnl9IGZpZWxkVmFsdWUgTyB2YWxvciBkbyBjYW1wby5cclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBQcm9tZXNzYSBxdWUgw6kgcmVzb2x2aWRhIGNvbSBvIGl0ZW0gcXVlIGZvaSBlbmNvbnRyYWRvLlxyXG4gICAqL1xyXG4gIGdldEl0ZW1CeUZpZWxkKGtleTogc3RyaW5nLCBmaWVsZE5hbWU6IHN0cmluZywgZmllbGRWYWx1ZTogYW55KTogUHJvbWlzZTxhbnk+IHtcclxuICAgIHJldHVybiB0aGlzLmdldChrZXkpLnRoZW4oKHN0b3JhZ2VSZWNvcmRzOiBBcnJheTxhbnk+KSA9PiB7XHJcbiAgICAgIGxldCBzdG9yYWdlUmVjb3Jkc0ZpbHRlcmVkID0gc3RvcmFnZVJlY29yZHMuZmluZChzdG9yYWdlUmVjb3JkID0+IHN0b3JhZ2VSZWNvcmRbZmllbGROYW1lXSA9PT0gZmllbGRWYWx1ZSk7XHJcbiAgICAgIHN0b3JhZ2VSZWNvcmRzRmlsdGVyZWQgPSBzdG9yYWdlUmVjb3Jkc0ZpbHRlcmVkIHx8IG51bGw7XHJcblxyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHN0b3JhZ2VSZWNvcmRzRmlsdGVyZWQpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMaXN0YSBjb20gdG9kYXMgYXMgY2hhdmVzIGFybWF6ZW5hZGFzLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8c3RyaW5nPj59IFByb21lc3NhIHF1ZSDDqSByZXNvbHZpZGEgY29tIHRvZGFzIGFzIGNoYXZlcyBhcm1hemVuYWRhcy5cclxuICAgKi9cclxuICBrZXlzKCk6IFByb21pc2U8QXJyYXk8c3RyaW5nPj4ge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZVByb21pc2UudGhlbihzdG9yZSA9PiBzdG9yZS5rZXlzKCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUXVhbnRpZGFkZSBkZSBjaGF2ZXMgYXJtYXplbmFkYXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fSBQcm9tZXNzYSBxdWUgw6kgcmVzb2x2aWRhIGNvbSBvIG7Dum1lcm8gZGUgY2hhdmVzIGFybWF6ZW5hZGFzLlxyXG4gICAqL1xyXG4gIGxlbmd0aCgpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZVByb21pc2UudGhlbihzdG9yZSA9PiBzdG9yZS5sZW5ndGgoKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVdGlsaXphZG8gcGFyYSBnZXJlbmNpYXIgbyBibG9xdWVpbyBlIGRlc2Jsb3F1ZWlvIGRlIHJlY3Vyc29zIG5vIGBQb1N0b3JhZ2VTZXJ2aWNlYC5cclxuICAgKiBBZ3VhcmRhbmRvIGEgbGliZXJhw6fDo28gZGEgdXRpbGl6YcOnw6NvIGRvcyByZWN1cnNvcyBxdWUgcGFydGljaXBhbSBkZXN0ZSBjb21wb3J0YW1lbnRvIGUgcG9zdGVyaW9ybWVudGUgZW52b2x2ZSBvIHJlY3Vyc29cclxuICAgKiBwYXNzYWRvIGNvbW8gcGFyw6JtZXRybyBlbSB1bSBjb21wb3J0YW1lbnRvIGRlIGJsb3F1ZWlvIGUgZGVzYmxvcXVlaW8uXHJcbiAgICpcclxuICAgKiBFc3RlIG3DqXRvZG8gc2UgY29tcG9ydGEgaWd1YWwgYSB1dGlsaXphw6fDo28gZW0gY29uanVudGEgZG9zIG3DqXRvZG9zOiBgUG9TdG9yYWdlU2VydmljZS5yZXF1ZXN0SWRsZVByb21pc2UoKWAsXHJcbiAgICogYFBvU3RvcmFnZVNlcnZpY2UubG9jaygpYCBlIGBQb1N0b3JhZ2VTZXJ2aWNlLnVubG9vaygpYC5cclxuICAgKlxyXG4gICAqIFZlamEgbWFpcyBubyBtw6l0b2RvOiBbYFBvU3RvcmFnZS5yZXF1ZXN0SWRsZVByb21pc2UoKWBdKGRvY3VtZW50YXRpb24vcG8tc3RvcmFnZSNyZXF1ZXN0LWlkbGUtcHJvbWlzZSkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaW1pdGVkUmVzb3VyY2UgRnVuw6fDo28gcXVlIHNlcsOhIGVudm9sdmlkYSBubyBjb21wb3J0YW1lbnRvIGRlIGJsb3F1ZWlvIGUgZGVzYmxvcXVlaW8uXHJcbiAgICovXHJcbiAgYXN5bmMgbGltaXRlZENhbGxXcmFwKGxpbWl0ZWRSZXNvdXJjZTogRnVuY3Rpb24pOiBQcm9taXNlPGFueT4ge1xyXG4gICAgYXdhaXQgdGhpcy5yZXF1ZXN0SWRsZVByb21pc2UoKTtcclxuICAgIHJldHVybiB0aGlzLmlkbGVRdWV1ZS53cmFwQ2FsbChsaW1pdGVkUmVzb3VyY2UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5jcmVtZW50YSB1bSB2YWxvciBuYSBmaWxhIGRlIGJsb3F1ZWlvIGRvIGBQb1N0b3JhZ2VTZXJ2aWNlYC4gVXRpbGl6YWRvIGp1bnRhbWVudGUgY29tIG8gbcOpdG9kbyBgdW5sb2NrYCBwYXJhIHBvZGVyXHJcbiAgICogY29udHJvbGFyIGEgZXhlY3XDp8OjbyBkZSB1bWEgZGV0ZXJtaW5hZGEgdGFyZWZhIGNvbSBvIGBQb1N0b3JhZ2UucmVxdWVzdElkbGVQcm9taXNlKClgLlxyXG4gICAqXHJcbiAgICogVmVqYSBtYWlzIG5vIG3DqXRvZG86IFtgUG9TdG9yYWdlLnJlcXVlc3RJZGxlUHJvbWlzZSgpYF0oZG9jdW1lbnRhdGlvbi9wby1zdG9yYWdlI3JlcXVlc3QtaWRsZS1wcm9taXNlKS5cclxuICAgKi9cclxuICBsb2NrKCkge1xyXG4gICAgdGhpcy5pZGxlUXVldWUubG9jaygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5hIHNlIG8gcHJvY2Vzc28gZGUgaW5pY2lhbGl6YcOnw6NvIGRvICpkcml2ZXIqIGFzc8OtbmNyb25vIGZvaSBjb25jbHXDrWRvLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge1Byb21pc2U8TG9jYWxGb3JhZ2U+fSBQcm9tZXNzYSBxdWUgw6kgcmVzb2x2aWRhIHF1YW5kbyBvIHByb2Nlc3NvIGRlIGluaWNpYWxpemHDp8OjbyBkbyAqZHJpdmVyKiBhc3PDrW5jcm9ub1xyXG4gICAqIGZvciBjb25jbHXDrWRvLlxyXG4gICAqL1xyXG4gIHJlYWR5KCk6IFByb21pc2U8TG9jYWxGb3JhZ2U+IHtcclxuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VQcm9taXNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIHVtIHZhbG9yIGFzc29jaWFkbyBhIHVtYSBjaGF2ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7a2V5fSBrZXkgQ2hhdmUgZG8gdmFsb3IgcXVlIHNlcsOhIHJlbW92aWRvLlxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFByb21lc3NhIHF1ZSDDqSByZXNvbHZpZGEgYXDDs3MgbyB2YWxvciBzZXIgcmVtb3ZpZG8uXHJcbiAgICovXHJcbiAgcmVtb3ZlKGtleTogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcclxuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VQcm9taXNlLnRoZW4oc3RvcmUgPT4gc3RvcmUucmVtb3ZlSXRlbShrZXkpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSB1bWEgcHJvcHJpZWRhZGUgZGUgdW0gb2JqZXRvIGFybWF6ZW5hZG8uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IENoYXZlIGRvIG9iamV0byBhcm1hemVuYWRvLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wcmllZGFkZSBxdWUgc2Vyw6EgcmVtb3ZpZGEuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBQcm9tZXNzYSBxdWUgw6kgcmVzb2x2aWRhIGFww7NzIGEgcHJvcHJpZWRhZGUgc2VyIHJlbW92aWRhLlxyXG4gICAqL1xyXG4gIGFzeW5jIHJlbW92ZUluZGV4RnJvbU9iamVjdChrZXk6IHN0cmluZywgcHJvcGVydHk6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XHJcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5nZXRPYmplY3RPZlN0b3JhZ2Uoa2V5KTtcclxuXHJcbiAgICBkZWxldGUgZGF0YVtwcm9wZXJ0eV07XHJcbiAgICByZXR1cm4gdGhpcy5zZXQoa2V5LCBkYXRhKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSB1bSBvYmpldG8gZGUgdW1hIGxpc3RhIGFybWF6ZW5hZGEgcGVsbyB2YWxvciBkZSB1bWEgcHJvcHJpZWRhZGUuXHJcbiAgICpcclxuICAgKiBQb3IgZXhlbXBsbzpcclxuICAgKlxyXG4gICAqIGBgYCB0eXBlc2NyaXB0XHJcbiAgICogY29uc3QgY2xpZW50cyA9IFsgeyBuYW1lOiAnTWFyaWUnLCBhZ2U6IDIzIH0sIHsgbmFtZTogJ1BldGhlcicsIGFnZTogMzkgfV07XHJcbiAgICpcclxuICAgKiB0aGlzLnBvU3RvcmFnZVNlcnZpY2Uuc2V0KCdjbGllbnRLZXknLCBjbGllbnRzKS50aGVuKCgpID0+IHt9KTtcclxuICAgKlxyXG4gICAqIC4uLlxyXG4gICAqXHJcbiAgICogdGhpcy5wb1N0b3JhZ2VTZXJ2aWNlLnJlbW92ZUl0ZW1Gcm9tQXJyYXkoJ2NsaWVudEtleScsICduYW1lJywgJ01hcmllJykudGhlbigoKSA9PiB7XHJcbiAgICogICAvLyBPIG9iamV0byB7IG5hbWU6ICdNYXJpZScsIGFnZTogMjMgfSBmb2kgcmVtb3ZpZG8gZGEgbGlzdGEgcXVlIGVzdMOhIG5hIGNoYXZlICdjbGllbnRLZXknXHJcbiAgICogfSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IENoYXZlIGRhIGxpc3RhIHF1ZSBjb250w6ltIG8gaXRlbSBxdWUgc2Vyw6EgcmVtb3ZpZG8uXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIE8gY2FtcG8gYSBzZXIgZmlsdHJhZG8gbm8gaXRlbS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgTyB2YWxvciBkbyBmaWx0cm8uXHJcbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gUHJvbWVzc2EgcXVlIMOpIHJlc29sdmlkYSBxdWFuZG8gbyBvYmpldG8gZm9yIHJlbW92aWRvIGRhIGxpc3RhLlxyXG4gICAqL1xyXG4gIGFzeW5jIHJlbW92ZUl0ZW1Gcm9tQXJyYXkoa2V5OiBzdHJpbmcsIGZpZWxkOiBzdHJpbmcsIHZhbHVlOiBhbnkpOiBQcm9taXNlPGFueT4ge1xyXG4gICAgbGV0IGRhdGEgPSBhd2FpdCB0aGlzLmdldEFycmF5T2ZTdG9yYWdlKGtleSk7XHJcblxyXG4gICAgZGF0YSA9IGRhdGEuZmlsdGVyKGl0ZW0gPT4gaXRlbVtmaWVsZF0gIT09IHZhbHVlKTtcclxuICAgIHJldHVybiB0aGlzLnNldChrZXksIGRhdGEpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogPGEgaWQ9XCJyZXF1ZXN0LWlkbGUtcHJvbWlzZVwiPjwvYT5cclxuICAgKiBNw6l0b2RvIHF1ZSB2ZXJpZmljYSBzZSBvIGFjZXNzbyBhIGJhc2UgZGUgZGFkb3MgY29uZmlndXJhZGEgZXN0w6EgbGliZXJhZG8uXHJcbiAgICpcclxuICAgKiBVdGlsaXphZG8gZW0gY29uanVudG8gY29tIG9zIG3DqXRvZG9zIGBsb2NrKClgIGUgYHVubG9jaygpYCBlbnRyZSB0YXJlZmFzIHF1ZSBuw6NvIHBvZGVtIHNlciBleGVjdXRhZGFzIGRlIGZvcm1hXHJcbiAgICogcGFyYWxlbGEsIHBhcmEgbsOjbyBjYXVzYXIgaW5jb25zaXN0w6puY2lhcyBub3MgZGFkb3MuXHJcbiAgICpcclxuICAgKiBFeGVtcGxvIGRlIHV0aWxpemHDp8OjbzpcclxuICAgKlxyXG4gICAqIGBgYFxyXG4gICAqIC8vIEFndWFyZGEgYSBsaWJlcmHDp8OjbyBwYXJhIGNvbnRpbnVhclxyXG4gICAqIGF3YWl0IHRoaXMucG9TdG9yYWdlLnJlcXVlc3RJZGxlUHJvbWlzZSgpO1xyXG4gICAqXHJcbiAgICogdGhpcy5wb1N0b3JhZ2UubG9jaygpO1xyXG4gICAqXHJcbiAgICogLy8gRXhlY3V0YSB1bWEgdGFyZWZhIHF1ZSBpcsOhIGxlciBlL291IGVzY3JldmVyIG5hIGJhc2UgZGUgZGFkb3MgY29uZmlndXJhZGEuXHJcbiAgICpcclxuICAgKiB0aGlzLnBvU3RvcmFnZS51bmxvY2soKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqID4gw4kgaW1wb3J0YW50ZSBzZW1wcmUgdXRpbGl6w6EtbG8gYW50ZXMgZGUgZXhlY3V0YXIgb3MgbcOpdG9kb3MgYGxvY2soKWAgZSBgdW5sb2NrKClgIHBhcmEgZ2FyYW50aXIgcXVlIGEgdGFyZWZhIHPDs1xyXG4gICAqIHNlcsOhIGV4ZWN1dGFkYSBjYXNvIG8gYWNlc3NvIGVzdGVqYSBsaXZyZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFByb21lc3NhIHF1ZSDDqSByZXNvbHZpZGEgcXVhbmRvIG8gYWNlc3NvIGEgYmFzZSBkZSBkYWRvcyBjb25maWd1cmFkYSBlc3RpdmVyIGxpYmVyYWRvLlxyXG4gICAqL1xyXG4gIHJlcXVlc3RJZGxlUHJvbWlzZSgpOiBQcm9taXNlPGFueT4ge1xyXG4gICAgcmV0dXJuIHRoaXMuaWRsZVF1ZXVlLnJlcXVlc3RJZGxlUHJvbWlzZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR3JhdmEgdW0gdmFsb3IgZW0gdW1hIGRldGVybWluYWRhIGNoYXZlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBDaGF2ZSBwYXJhIG8gdmFsb3IgcXVlIHNlcsOhIGdyYXZhZG8uXHJcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlIFZhbG9yIHF1ZSBzZXLDoSBncmF2YWRvLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9jayBEZWZpbmUgc2UgaXLDoSB0cmF2YXIgYSBsZWl0dXJhIGUgYSBlc2NyaXRhIGRhIGJhc2UgZGUgZGFkb3MgcGFyYSBuw6NvIHNlciBhY2Vzc2FkYSBkZSBmb3JtYSBwYXJhbGVsYS5cclxuICAgKiBDYXNvIG91dHJhIGxlaXR1cmEvZXNjcml0YSBqw6EgdGVuaGEgc2lkbyBpbmljaWFkYSwgZXN0ZSBtw6l0b2RvIGlyw6EgZXNwZXJhciBvIG91dHJvIHRlcm1pbmFyIHBhcmEgZW50w6NvIGNvbWXDp2FyLlxyXG4gICAqXHJcbiAgICogUGFkcsOjbzogYGZhbHNlYC5cclxuICAgKlxyXG4gICAqID4gRXN0YSBkZWZpbmnDp8OjbyBzw7Mgc2Vyw6EgdsOhbGlkYSBzZSBvIG91dHJvIGFjZXNzbyBwYXJhbGVsbyBhIGVzdGUgbcOpdG9kbyB0YW1iw6ltIGVzdGl2ZXIgY29tIG8gcGFyw6JtZXRybyAqbG9jayogYXRpdmFkby5cclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBQcm9tZXNzYSBxdWUgw6kgcmVzb2x2aWRhIGFww7NzIG8gdmFsb3IgdGVyIHNpZG8gZ3JhdmFkby5cclxuICAgKi9cclxuICBhc3luYyBzZXQoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnksIGxvY2s6IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8YW55PiB7XHJcbiAgICBjb25zdCBzdG9yZSA9IGF3YWl0IHRoaXMuc3RvcmFnZVByb21pc2U7XHJcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSkgOiB2YWx1ZTtcclxuXHJcbiAgICBpZiAobG9jaykge1xyXG4gICAgICBhd2FpdCB0aGlzLnJlcXVlc3RJZGxlUHJvbWlzZSgpO1xyXG4gICAgICByZXR1cm4gdGhpcy5pZGxlUXVldWUud3JhcENhbGwoKCkgPT4gc3RvcmUuc2V0SXRlbShrZXksIG5ld1ZhbHVlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0b3JlLnNldEl0ZW0oa2V5LCBuZXdWYWx1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHJpYnVpIHVtIHZhbG9yIGEgdW1hIHByb3ByaWVkYWRlIGRlIHVtIG9iamV0byBhcm1hemVuYWRvIHBlbGEgY2hhdmUuXHJcbiAgICpcclxuICAgKiBQb3IgZXhlbXBsbzpcclxuICAgKlxyXG4gICAqIGBgYCB0eXBlc2NyaXB0XHJcbiAgICogY29uc3QgY2xpZW50cyA9IFsgeyBuYW1lOiAnTWFyaWUnLCBhZ2U6IDIzIH0sIHsgbmFtZTogJ1BldGhlcicsIGFnZTogMzkgfV07XHJcbiAgICpcclxuICAgKiB0aGlzLnBvU3RvcmFnZVNlcnZpY2Uuc2V0KCdjbGllbnRLZXknLCBjbGllbnRzKS50aGVuKCgpID0+IHt9KTtcclxuICAgKlxyXG4gICAqIC4uLlxyXG4gICAqXHJcbiAgICogdGhpcy5wb1N0b3JhZ2VTZXJ2aWNlLnNldEluZGV4VG9PYmplY3QoJ2NsaWVudEtleScsICduYW1lJywgJ0NsYXJlJykudGhlbigoKSA9PiB7XHJcbiAgICogICAvLyBPIG9iamV0byB7IG5hbWU6ICdNYXJpZScsIGFnZTogMjMgfSBwYXNzYSBhIHNlciB7IG5hbWU6ICdDbGFyZScsIGFnZTogMjMgfVxyXG4gICAqIH0pO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBDaGF2ZSBkbyBvYmpldG8uXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5vbWUgZGEgcHJvcHJpZWRhZGUgZG8gb2JqZXRvLlxyXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZSBWYWxvciBxdWUgc2Vyw6EgZ3JhdmFkbyBuYSBwcm9wcmllZGFkZSBkbyBvYmpldG8uXHJcbiAgICovXHJcbiAgYXN5bmMgc2V0SW5kZXhUb09iamVjdChrZXk6IHN0cmluZywgcHJvcGVydHk6IHN0cmluZywgdmFsdWU6IGFueSk6IFByb21pc2U8YW55PiB7XHJcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5nZXRPYmplY3RPZlN0b3JhZ2Uoa2V5KTtcclxuXHJcbiAgICBkYXRhW3Byb3BlcnR5XSA9IHZhbHVlO1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0KGtleSwgZGF0YSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZWNyZW1lbnRhIHVtIHZhbG9yIG5hIGZpbGEgZGUgYmxvcXVlaW8uIFV0aWxpemFkbyBqdW50YW1lbnRlIGNvbSBvIG3DqXRvZG8gYGxvY2tgIHBhcmEgcG9kZXJcclxuICAgKiBjb250cm9sYXIgYSBleGVjdcOnw6NvIGRlIHVtYSBkZXRlcm1pbmFkYSB0YXJlZmEgY29tIG8gYFBvU3RvcmFnZS5yZXF1ZXN0SWRsZVByb21pc2UoKWAuXHJcbiAgICpcclxuICAgKiBWZWphIG1haXMgbm8gbcOpdG9kbzogW2BQb1N0b3JhZ2UucmVxdWVzdElkbGVQcm9taXNlKClgXShkb2N1bWVudGF0aW9uL3BvLXN0b3JhZ2UjcmVxdWVzdC1pZGxlLXByb21pc2UpLlxyXG4gICAqL1xyXG4gIHVubG9jaygpIHtcclxuICAgIHRoaXMuaWRsZVF1ZXVlLnVubG9jaygpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBnZXRBcnJheU9mU3RvcmFnZShrZXk6IHN0cmluZykge1xyXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZ2V0KGtleSk7XHJcbiAgICByZXR1cm4gZGF0YSB8fCBbXTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgZ2V0SW1tdXRhYmxlSXRlbShrZXk6IHN0cmluZykge1xyXG4gICAgY29uc3Qgc3RvcmUgPSBhd2FpdCB0aGlzLnN0b3JhZ2VQcm9taXNlO1xyXG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCBzdG9yZS5nZXRJdGVtKGtleSk7XHJcbiAgICByZXR1cm4gaXRlbXMgPyBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGl0ZW1zKSkgOiBudWxsO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBkZWZpbmVMb2NhbEZvcmFnZURyaXZlcihsb2NhbEZvcmFnZUluc3RhbmNlOiBhbnksIGRyaXZlck9yZGVyKSB7XHJcbiAgICBhd2FpdCBsb2NhbEZvcmFnZUluc3RhbmNlLmRlZmluZURyaXZlcih0aGlzLmxva2lqc0RyaXZlci5nZXREcml2ZXIoKSk7XHJcbiAgICBhd2FpdCB0aGlzLnNldERyaXZlcihsb2NhbEZvcmFnZUluc3RhbmNlLCBkcml2ZXJPcmRlcik7XHJcbiAgICByZXR1cm4gbG9jYWxGb3JhZ2VJbnN0YW5jZTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2V0RHJpdmVyT3JkZXIoZHJpdmVyT3JkZXI6IEFycmF5PHN0cmluZz4pOiBBcnJheTxzdHJpbmc+IHtcclxuICAgIHJldHVybiBkcml2ZXJPcmRlci5tYXAoZHJpdmVyID0+IHtcclxuICAgICAgc3dpdGNoIChkcml2ZXIpIHtcclxuICAgICAgICBjYXNlICdpbmRleGVkZGInOlxyXG4gICAgICAgICAgcmV0dXJuIExvY2FsRm9yYWdlLklOREVYRUREQjtcclxuICAgICAgICBjYXNlICd3ZWJzcWwnOlxyXG4gICAgICAgICAgcmV0dXJuIExvY2FsRm9yYWdlLldFQlNRTDtcclxuICAgICAgICBjYXNlICdsb2NhbHN0b3JhZ2UnOlxyXG4gICAgICAgICAgcmV0dXJuIExvY2FsRm9yYWdlLkxPQ0FMU1RPUkFHRTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgcmV0dXJuIGRyaXZlcjtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGdldE9iamVjdE9mU3RvcmFnZShrZXk6IHN0cmluZykge1xyXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZ2V0KGtleSk7XHJcbiAgICByZXR1cm4gZGF0YSB8fCB7fTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgc2V0RHJpdmVyKGxvY2FsRm9yYWdlSW5zdGFuY2U6IExvY2FsRm9yYWdlLCBkcml2ZXJPcmRlcikge1xyXG4gICAgYXdhaXQgbG9jYWxGb3JhZ2VJbnN0YW5jZS5zZXREcml2ZXIodGhpcy5nZXREcml2ZXJPcmRlcihkcml2ZXJPcmRlcikpO1xyXG4gICAgdGhpcy5kcml2ZXIgPSBsb2NhbEZvcmFnZUluc3RhbmNlLmRyaXZlcigpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzZXRTdG9yYWdlUHJvbWlzZShjb25maWc6IFBvU3RvcmFnZUNvbmZpZykge1xyXG4gICAgdGhpcy5zdG9yYWdlUHJvbWlzZSA9IHRoaXMuZ2V0U3RvcmFnZUluc3RhbmNlKGNvbmZpZyk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGdldFN0b3JhZ2VJbnN0YW5jZShjb25maWc6IFBvU3RvcmFnZUNvbmZpZykge1xyXG4gICAgY29uc3QgZGVmYXVsdENvbmZpZyA9IFBvU3RvcmFnZVNlcnZpY2UuZ2V0RGVmYXVsdENvbmZpZygpO1xyXG4gICAgY29uc3QgYWN0dWFsQ29uZmlnID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0Q29uZmlnLCBjb25maWcgfHwge30pO1xyXG5cclxuICAgIGNvbnN0IGxvY2FsRm9yYWdlSW5zdGFuY2UgPSBMb2NhbEZvcmFnZS5jcmVhdGVJbnN0YW5jZShhY3R1YWxDb25maWcpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmRlZmluZUxvY2FsRm9yYWdlRHJpdmVyKGxvY2FsRm9yYWdlSW5zdGFuY2UsIGFjdHVhbENvbmZpZy5kcml2ZXJPcmRlcik7XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgdXNlIHRoaXMgZHJpdmVyczogJHthY3R1YWxDb25maWcuZHJpdmVyT3JkZXIuam9pbignLCAnKX0uYCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiJdfQ==